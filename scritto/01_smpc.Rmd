# Secure multi-party computation
La Secure multi-party computation (SMPC) è una sottocategoria della crittografia che ha come obiettivo quello di creare metodi di calcolo congiunto di una funzione sugli input privati di 2 o più parti coinvolte.

A differenza dei compiti crittografici tradizionali, dove la crittografia garantisce la sicurezza e l'integrità della comunicazione o dell'archiviazione e l'avversario è esterno al sistema dei partecipanti, la crittografia in questo modello protegge la privacy dei partecipanti l'uno dall'altro.

Ci troviamo in un periodo in cui i dati diventano via via sempre più centrali e, ad oggi, infatti, oggetto di interesse per le aziende essi non saranno più semplici informazioni, bensì si trasformano in potenziali nuovi metodi di guadagno. La monetizzazione dei dati è  il modello di business primario comune a molte delle più grandi aziende, nonché la priorità di tante altre.

L’applicazione di un simile modello di business richiede tuttavia la raccolta di grandi quantità di dati, e il successo è tanto più significativo quante più correlazioni e rapporti di casualità è possibile trovare combinando diverse fonti dati. E' necessario però considerare tutte le problematiche derivanti da questa dinamica

Il sottoprodotto di questo processo è, ad esempio, una possibile violazione della privacy individuale, in quanto le aziende posseggono molte informazioni personali dei loro utenti.

Sono state pensate dunque, per far fronte a questo precedente, soluzioni in cui sia possibile utilizzare fonti dati diverse senza la necessità di centralizzare l'informazione. In questo modo è possibile garantire che nessuna informazione venga rivelata nel corso delle operazioni. 

Queste sono le premesse della Secure multiparty computation (SMPC). In altri termini, saremmo così in grado di consentire ai Data Scientist e Data Analyst di operare sui dati senza il bisogno di esporli o spostarli dalla loro sede di storage. 

## Panoramica

In una SMPC un dato numero di partecipanti $p_1, p_2, ..., p_N$, ognuno dei quali ha dei dati privati $d_1, d_2, ..., d_N$. I partecipanti vogliono calcolare il valore di una funzione pubblica con i loro dati privati: $F(d_1, d_2, ..., d_N)$ mantenendo i loro input segreti.


Per esempio, supponiamo di avere tre parti Alice, Bob e Charlie, con i rispettivi input x, y e z che denotano i loro stipendi. Vogliono scoprire il più alto dei tre stipendi, senza rivelare all'altro quanto guadagna ognuno di loro. Matematicamente, questo si traduce in un calcolo: $F(x, y, z) = max(x, y, z)$

Se ci fosse una parte esterna fidata (diciamo che hanno un amico comune, Tony, che deve mantenere i segreti delle parti), ognuno potrebbe dire il proprio stipendio a Tony, lui potrebbe calcolare il massimo e dire quel numero a tutti loro.

L'obiettivo di SMPC è di progettare un protocollo in cui, scambiando messaggi solo tra di loro, Alice, Bob e Charlie possono ancora calcolare $F(x, y, z)$ senza rivelare chi fa cosa e senza dover dipendere da terzi. Non dovrebbero saperne di più, impegnandosi nel loro protocollo, di quanto saprebbero interagendo con un Tony incorruttibile e perfettamente degno di fiducia.

In particolare, tutto ciò che le parti possono sapere è ciò che loro possono apprendere dall'output e dal loro stesso input. Così nell'esempio precedente, se l'output è $z$, allora Charlie impara che il suo $z$ è il valore massimo, mentre Alice e Bob imparano (se $x$, $y$ e $z$ sono distinti), che il loro input non è uguale al massimo, e che il massimo è uguale a $z$. Lo scenario di base può essere facilmente generalizzato ai casi in cui le parti hanno diversi input e output, e la funzione fornisce valori diversi alle diverse parti.

\newpage

Un protocollo di calcolo sicuro multipartitico deve offrire alcune garanzie di sicurezza, persino se alcune delle parti fossero in collusione o cercassero di violarne le regole:

- **Input Privacy**: Nessuna delle parti corrotte (o suo sottoinsieme) deve essere in grado di derivare alcuna informazione sui dati appartenenti alle altre parti, a eccezione di quanto rivelato dal risultato dell’operazione
- **Correctness**: Nessuna delle parti corrotte (o suo sottoinsieme) deve essere in grado di indurre una parte onesta a produrre un risultato errato.

## Garanzie di sicurezza

Un protocollo di calcolo a più parti deve essere sicuro per essere efficace. Nella crittografia moderna, la sicurezza di un protocollo è legata a una dimostrazione di sicurezza. La dimostrazione di sicurezza è una dimostrazione matematica in cui la sicurezza di un protocollo è ridotta a quella della sicurezza delle sue primitive sottostanti. Tuttavia, non è sempre possibile formalizzare la verifica di sicurezza del protocollo crittografico basata sulla conoscenza delle parti e sulla correttezza del protocollo. Per i protocolli MPC, l'ambiente in cui il protocollo opera è associato al paradigma del mondo reale/mondo ideale. Non si può dire che le parti non imparino nulla, poiché devono imparare l'output dell'operazione, e l'output dipende dagli input. Inoltre, la correttezza dell'output non è garantita, poiché la correttezza dell'output dipende dagli input delle parti, e si deve supporre che gli input siano corrotti.

Il paradigma del mondo reale/mondo ideale afferma due mondi: 

- Nel **modello del mondo ideale**, esiste una parte incorruttibile fidata a cui ogni partecipante al protocollo invia il suo input. Questa parte fidata calcola la funzione da sola e rimanda l'output appropriato ad ogni parte. 
- Al contrario, nel **modello del mondo reale**, non esiste una parte fidata e tutto ciò che le parti possono fare è scambiare messaggi tra loro. Un protocollo è detto sicuro se non si può imparare di più sugli input privati di ogni parte nel mondo reale di quanto si potrebbe imparare nel mondo ideale. Nel mondo ideale, nessun messaggio viene scambiato tra le parti, quindi i messaggi scambiati nel mondo reale non possono rivelare alcuna informazione segreta.

\newpage

Il paradigma mondo reale/mondo ideale fornisce una semplice astrazione delle complessità di MPC per consentire la costruzione di un'applicazione sotto la premessa che il protocollo MPC nel suo nucleo sia in realtà un'esecuzione ideale. Se l'applicazione è sicura nel caso ideale, allora è sicura anche quando viene eseguito un protocollo reale.

A differenza delle applicazioni crittografiche tradizionali, come la crittografia o la firma, si deve assumere che l'avversario in un protocollo MPC sia uno dei giocatori impegnati nel sistema (o che controlla le parti interne). Quella/e parti corrotte possono colludere per violare la sicurezza del protocollo. 

Sia $n$ il numero di parti nel protocollo e $t$ il numero di parti che possono essere avversarie. I protocolli e le soluzioni per il caso di $t<n/2$ (cioè quando si assume una maggioranza onesta) sono diversi da quelli in cui non viene fatta tale assunzione. Quest'ultimo caso include l'importante caso di calcolo a due parti in cui uno dei partecipanti può essere corrotto, e il caso generale in cui un numero illimitato di partecipanti è corrotto e collude per attaccare i partecipanti onesti.

Gli avversari affrontati dai diversi protocolli possono essere classificati in base a quanto sono disposti a deviare dal protocollo. Ci sono essenzialmente due tipi di avversari, ognuno dei quali dà luogo a diverse forme di sicurezza (e ognuno si adatta a diversi scenari del mondo reale):

- **Sicurezza semi-onesta (passiva)**: In questo caso, si assume che le parti corrotte cooperino semplicemente per raccogliere informazioni dal protocollo, ma non si discostino dalle specifiche del protocollo. Questo è un tipo di avversario semplice e ingenuo, che produce una sicurezza debole in situazioni reali. Tuttavia, i protocolli che raggiungono questo livello di sicurezza impediscono la perdita involontaria di informazioni tra le parti (altrimenti collaboranti), e sono quindi utili se questa è l'unica preoccupazione. Inoltre, i protocolli nel modello semi-onesto sono abbastanza efficienti, e sono spesso un primo passo importante per raggiungere livelli più alti di sicurezza.
- **Sicurezza malevola (attiva)**: In questo caso, l'avversario può arbitrariamente discostarsi dall'esecuzione del protocollo nel suo tentativo di ingannare. I protocolli che raggiungono la sicurezza in questo modello forniscono una garanzia di sicurezza molto alta. Nel caso di maggioranza delle parti che si comportano scorrettamente: L'unica cosa che un avversario può fare nel caso di maggioranza disonesta è far sì che le parti oneste interrompano avendo rilevato l'imbroglio. Se le parti oneste ottengono l'output, allora hanno la garanzia che sia corretto. La loro privacy è sempre preservata.

\newpage

La sicurezza contro gli avversari attivi porta tipicamente ad una riduzione dell'efficienza che porta alla sicurezza nascosta, una forma ridotta di sicurezza attiva. La sicurezza nascosta cattura situazioni più realistiche, in cui gli avversari attivi sono disposti a barare ma solo se non vengono scoperti. Per esempio, la loro reputazione potrebbe essere danneggiata, impedendo la futura collaborazione con altre parti oneste. 

Quindi, i protocolli che sono segretamente sicuri forniscono meccanismi per garantire che, se alcune delle parti non seguono le istruzioni, allora sarà notato con alta probabilità. In un certo senso, gli avversari segreti sono quelli attivi costretti ad agire passivamente a causa di preoccupazioni esterne non crittografiche (ad esempio il business). Questo meccanismo stabilisce un ponte tra i due modelli nella speranza di trovare protocolli che siano efficienti e abbastanza sicuri nella pratica.

Come molti protocolli crittografici, la sicurezza di un protocollo MPC può basarsi su diversi presupposti:

- **Computazionale** (cioè basata su qualche problema matematico, come la fattorizzazione) o **incondizionata**, cioè basata sull'indisponibilità fisica dei messaggi sui canali (di solito con qualche probabilità di errore che può essere resa arbitrariamente ridotta).
- Il modello potrebbe assumere che i partecipanti utilizzino una rete sincronizzata, dove un messaggio inviato a un "tick" arriva sempre al "tick" successivo, o che esista un canale di trasmissione sicuro e affidabile, o che esista un canale di comunicazione sicuro tra ogni coppia di partecipanti dove un avversario non può leggere, modificare o generare messaggi nel canale, ecc.

\newpage

## Two-party computation

Una particolare sotto-categoria delle SMPC è la Two-party computation. Questa categoria descrive uno scenario in cui 2 parti parti comunicano tra di loro per la risoluzione di un problema senza scambiarsi informazioni sensibili e senza l'utilizzo di una terza parte fidata. 

Lo scenario a due parti è particolarmente interessante, non solo dal punto di vista delle applicazioni, ma anche perché si possono applicare tecniche speciali nel contesto a due parti che non si applicano nel caso a più parti. Infatti, il calcolo sicuro a più parti è stato presentato per la prima volta nell'impostazione a due parti. Il lavoro originale è spesso citato come proveniente da uno dei due articoli di Yao; anche se gli articoli non contengono effettivamente quello che ora è noto come il Yao's garbled circuit protocol.

Il protocollo di base di Yao è sicuro contro gli avversari semi-onesti ed è estremamente efficiente in termini di numero di passaggi, che è costante, e indipendente dalla funzione obiettivo che viene valutata. La funzione è vista come un circuito booleano, con ingressi in binario di lunghezza fissa. Un circuito booleano è un insieme di porte collegate con tre diversi tipi di fili: fili di ingresso al circuito, fili di uscita al circuito e fili intermedi. Ogni porta riceve due fili d'ingresso e ha un singolo filo d'uscita che potrebbe essere fan-out (cioè essere passato a più porte al livello successivo). La semplice valutazione del circuito viene fatta valutando ogni porta a turno; assumendo che le porte siano state ordinate topologicamente. Il gate è rappresentato come una tabella di verità tale che per ogni possibile coppia di bit (quelli provenienti dal gate dei fili di ingresso) la tabella assegna un unico bit di uscita; che è il valore del filo di uscita del gate. I risultati della valutazione sono i bit ottenuti nei fili di uscita del circuito.

Yao ha spiegato come confondere un circuito (nascondere la sua struttura) in modo che due parti, mittente e ricevitore, possano imparare l'uscita del circuito e nient'altro. Ad un alto livello, il mittente prepara il circuito confuso e lo invia al ricevitore, che ignaro valuta il circuito, imparando le codifiche corrispondenti all'uscita sua e del mittente. Poi si limita a rimandare le codifiche del mittente, permettendo a quest'ultimo di calcolare la sua parte di output. Il mittente invia la mappatura dalle codifiche di uscita dei ricevitori ai bit al ricevitore, permettendo a quest'ultimo di ottenere la propria uscita. Nel capitolo successivo andremo più in profondità spiegando dettagliatamente la logica di funzionamento.