<!DOCTYPE html>
<html lang="it" xml:lang="it">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 Yao Garbled Circuit | Tesi</title>
  <meta name="description" content="2 Yao Garbled Circuit | Tesi" />
  <meta name="generator" content="bookdown 0.23 and GitBook 2.6.7" />

  <meta property="og:title" content="2 Yao Garbled Circuit | Tesi" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 Yao Garbled Circuit | Tesi" />
  
  
  

<meta name="author" content="Andrea Locatelli" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="secure-multi-party-computation.html"/>
<link rel="next" href="analisi.html"/>
<script src="libs/header-attrs-2.10/header-attrs.js"></script>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script>
<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="secure-multi-party-computation.html"><a href="secure-multi-party-computation.html"><i class="fa fa-check"></i><b>1</b> Secure multi-party computation</a>
<ul>
<li class="chapter" data-level="1.1" data-path="secure-multi-party-computation.html"><a href="secure-multi-party-computation.html#panoramica"><i class="fa fa-check"></i><b>1.1</b> Panoramica</a></li>
<li class="chapter" data-level="1.2" data-path="secure-multi-party-computation.html"><a href="secure-multi-party-computation.html#garanzie-di-sicurezza"><i class="fa fa-check"></i><b>1.2</b> Garanzie di sicurezza</a></li>
<li class="chapter" data-level="1.3" data-path="secure-multi-party-computation.html"><a href="secure-multi-party-computation.html#two-party-computation"><i class="fa fa-check"></i><b>1.3</b> Two-party computation</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="yao-garbled-circuit.html"><a href="yao-garbled-circuit.html"><i class="fa fa-check"></i><b>2</b> Yao Garbled Circuit</a>
<ul>
<li class="chapter" data-level="2.1" data-path="yao-garbled-circuit.html"><a href="yao-garbled-circuit.html#garbling-logical-gates"><i class="fa fa-check"></i><b>2.1</b> Garbling Logical Gates</a></li>
<li class="chapter" data-level="2.2" data-path="yao-garbled-circuit.html"><a href="yao-garbled-circuit.html#valutazione-del-garbled-circuit"><i class="fa fa-check"></i><b>2.2</b> Valutazione del Garbled Circuit</a></li>
<li class="chapter" data-level="2.3" data-path="yao-garbled-circuit.html"><a href="yao-garbled-circuit.html#permute-and-point"><i class="fa fa-check"></i><b>2.3</b> Permute-and-point</a></li>
<li class="chapter" data-level="2.4" data-path="yao-garbled-circuit.html"><a href="yao-garbled-circuit.html#esempio-di-valutazione"><i class="fa fa-check"></i><b>2.4</b> Esempio di Valutazione</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="analisi.html"><a href="analisi.html"><i class="fa fa-check"></i><b>3</b> Analisi</a>
<ul>
<li class="chapter" data-level="3.1" data-path="analisi.html"><a href="analisi.html#studio-del-circuito-binario"><i class="fa fa-check"></i><b>3.1</b> Studio del circuito binario</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="analisi.html"><a href="analisi.html#analisi-della-struttura-pla"><i class="fa fa-check"></i><b>3.1.1</b> Analisi della struttura PLA</a></li>
<li class="chapter" data-level="3.1.2" data-path="analisi.html"><a href="analisi.html#la-gestione-dei-dont-care-durante-la-conversione"><i class="fa fa-check"></i><b>3.1.2</b> La gestione dei don’t care durante la conversione</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="analisi.html"><a href="analisi.html#implementazione-della-conversione"><i class="fa fa-check"></i><b>3.2</b> Implementazione della conversione</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="analisi.html"><a href="analisi.html#analisi-del-circuito"><i class="fa fa-check"></i><b>3.2.1</b> Analisi del circuito</a></li>
<li class="chapter" data-level="3.2.2" data-path="analisi.html"><a href="analisi.html#espansione-dei-dont-care"><i class="fa fa-check"></i><b>3.2.2</b> Espansione dei don’t care</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="analisi.html"><a href="analisi.html#la-conversione-in-multi-valore"><i class="fa fa-check"></i><b>3.3</b> La conversione in multi valore</a></li>
<li class="chapter" data-level="3.4" data-path="analisi.html"><a href="analisi.html#la-creazione-del-file-blfmv"><i class="fa fa-check"></i><b>3.4</b> La creazione del file blfmv</a></li>
<li class="chapter" data-level="3.5" data-path="analisi.html"><a href="analisi.html#la-sintesi"><i class="fa fa-check"></i><b>3.5</b> La sintesi</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="analisi.html"><a href="analisi.html#mvsis"><i class="fa fa-check"></i><b>3.5.1</b> MVSIS</a></li>
<li class="chapter" data-level="3.5.2" data-path="analisi.html"><a href="analisi.html#abc"><i class="fa fa-check"></i><b>3.5.2</b> ABC</a></li>
<li class="chapter" data-level="3.5.3" data-path="analisi.html"><a href="analisi.html#la-sintesi-tramite-i-software"><i class="fa fa-check"></i><b>3.5.3</b> La sintesi tramite i software</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="analisi.html"><a href="analisi.html#il-calcolo-dei-costi-del-circuito"><i class="fa fa-check"></i><b>3.6</b> Il calcolo dei costi del circuito</a>
<ul>
<li class="chapter" data-level="3.6.1" data-path="analisi.html"><a href="analisi.html#blfmv-vs-pla"><i class="fa fa-check"></i><b>3.6.1</b> blfmv vs pla</a></li>
<li class="chapter" data-level="3.6.2" data-path="analisi.html"><a href="analisi.html#implementazione"><i class="fa fa-check"></i><b>3.6.2</b> Implementazione</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="analisi.html"><a href="analisi.html#automatizzazione-dei-processi"><i class="fa fa-check"></i><b>3.7</b> Automatizzazione dei processi</a>
<ul>
<li class="chapter" data-level="3.7.1" data-path="analisi.html"><a href="analisi.html#struttura"><i class="fa fa-check"></i><b>3.7.1</b> Struttura</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html"><i class="fa fa-check"></i><b>4</b> Risultati sperimentali</a>
<ul>
<li class="chapter" data-level="4.1" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html#mvsis-1"><i class="fa fa-check"></i><b>4.1</b> MVSIS</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html#conversione-multivalore-fissa"><i class="fa fa-check"></i><b>4.1.1</b> Conversione multivalore fissa</a></li>
<li class="chapter" data-level="4.1.2" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html#mvsis-e-dominio-variabile"><i class="fa fa-check"></i><b>4.1.2</b> MVSIS e dominio variabile</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html#abc-1"><i class="fa fa-check"></i><b>4.2</b> ABC</a></li>
<li class="chapter" data-level="4.3" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html#abc-e-dominio-fisso"><i class="fa fa-check"></i><b>4.3</b> ABC e dominio fisso</a></li>
<li class="chapter" data-level="4.4" data-path="risultati-sperimentali.html"><a href="risultati-sperimentali.html#abc-e-dominio-variabile"><i class="fa fa-check"></i><b>4.4</b> ABC e dominio variabile</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Tesi</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="yao-garbled-circuit" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Yao Garbled Circuit</h1>
<p>Si supponga che Alice e Bob siano disposti a calcolare in modo sicuro una funzione <span class="math inline">\(f(x, y)\)</span> mantenendo segreti i rispettivi input <span class="math inline">\(x\)</span> e <span class="math inline">\(y\)</span>.</p>
<p>Per fare ciò, essi modellano prima la funzione <span class="math inline">\(f\)</span> come un circuito booleano, questo è possibile poiché esiste un circuito booleano <span class="math inline">\(C\)</span> che calcola l’uscita di <span class="math inline">\(f\)</span> per qualsiasi funzione <span class="math inline">\(f\)</span> con ingressi di dimensione fissa. Tuttavia, il modo in cui tale modellazione viene eseguita può dipendere dalla funzione e non sarà ulteriormente discusso qui. Successivamente Alice confonderà il circuito booleano e:</p>
<ol style="list-style-type: decimal">
<li>Per ogni filo <span class="math inline">\(w_i\)</span> del circuito <span class="math inline">\(C\)</span>, sceglie casualmente due valori segreti <span class="math inline">\(w^{0}_{i}\)</span>, <span class="math inline">\(w^{1}_{i}\)</span>, dove <span class="math inline">\(w^{j}_{i}\)</span> è il valore confuso del valore <span class="math inline">\(j \in \{0,1\}\)</span> del filo <span class="math inline">\(w_i\)</span>. Si noti che <span class="math inline">\(w^{j}_{i}\)</span> non può rivelare <span class="math inline">\(j\)</span> di per sé, quindi Alice deve tenere traccia di <span class="math inline">\(i\)</span> e <span class="math inline">\(j\)</span>. Questo deve essere fatto per ogni singolo filo di ingresso e di uscita di ogni porta logica del circuito, tranne che per le porte di uscita del circuito che possono essere lasciate in chiaro.</li>
<li>Alice dovrà costruire una tabella di verità confusa (GTT) <span class="math inline">\(T_i\)</span> per ciascuna delle porte logiche <span class="math inline">\(G_i\)</span> in <span class="math inline">\(C\)</span>.</li>
</ol>
<div style="page-break-after: always;"></div>
<p>Queste tabelle devono essere tali che dati valori confusi lungo il suo insieme di fili d’ingresso, <span class="math inline">\(T_i\)</span> permetterà di recuperare l’uscita confusa di questo <span class="math inline">\(G_i\)</span> e nessun’altra informazione. Questo si ottiene attraverso la crittografia dei valori di uscita. Di seguito dettaglierò ulteriormente il garbling delle porte.</p>
<div class="figure"><span style="display:block;" id="fig:chunk-label"></span>
<img src="media/01.png" alt="AND gate con etichette e tabella di verità."  />
<p class="caption">
Figure 2.1: AND gate con etichette e tabella di verità.
</p>
</div>
<p>In seguito, Alice può tradurre ogni bit del suo input nei suoi corrispondenti valori confusi sui fili di ingresso del circuito. Successivamente può inviare il circuito, ora confuso, dove ogni porta è sostituita dal suo GTT a Bob con il suo input criptato.</p>
<p>Dopo che Bob ha ricevuto il circuito confuso, poiché tutti i fili d’ingresso sono criptati e solo Alice conosce la mappatura dei valori criptati e i bit reali, Bob ha bisogno di eseguire un Oblivious transfer con Alice per ciascuno dei suoi bit d’ingresso, in modo che Alice possa informarlo di quali valori criptati corrispondono ai suoi bit d’ingresso e sapere quali sono i suoi bit d’ingresso reali.</p>
<blockquote>
<p><strong>Oblivius transfer</strong>: tipo di protocollo in cui il mittente trasmette un pezzo di informazione a un ricevitore, tra tante potenziali, ma rimane ignaro al mittente quale pezzo di informazione sia stato trasmesso.</p>
</blockquote>
<p>Quindi significa che per ogni filo di ingresso, Bob sceglierà una tra le due stringhe casuali <span class="math inline">\(w^{0}_{i}\)</span>, <span class="math inline">\(w^{1}_{i}\)</span> che corrispondono rispettivamente a <span class="math inline">\(0\)</span> e <span class="math inline">\(1\)</span>, ma senza conoscere il contenuto della stringa che non sceglie. E grazie alle proprietà del Oblivious transfer Alice non può conoscere l’input di Bob.</p>
<p>Allora Bob ha tutti i valori necessari per calcolare l’uscita del circuito, come discuterò in seguito. Una volta fatto ciò, può comunicare i valori di uscita ad Alice. Così Bob è stato in grado di ottenere l’uscita di <span class="math inline">\(f\)</span> senza rivelare il suo input, né conoscere l’input di Alice, questo significa che Alice e Bob hanno simulato con successo una terza parte fidata e hanno eseguito un SMPC sicuro.</p>
<div style="page-break-after: always;"></div>
<div id="garbling-logical-gates" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Garbling Logical Gates</h2>
<p>La nozione di garbling delle porte logiche e della loro tabella di verità è cruciale. Senza perdita di generalità, considererò solo le porte logiche con due fili di ingresso e un filo di uscita. Come ho spiegato sopra, per una data porta <span class="math inline">\(G \in C\)</span> e i suoi fili d’ingresso <span class="math inline">\(W_0, W_1\)</span> e il suo filo di uscita <span class="math inline">\(W\)</span>, Alice doveva scegliere sei diverse stringhe casuali, <span class="math inline">\(w^{0}_{0}, w^{1}_{0}, w^{0}_{1}, w^{1}_{1}, w^0, w^1\)</span> che ha assegnato a ciascun valore dei fili in una mappatura uno a uno, dove <span class="math inline">\(w^{j}_{i}\)</span> rappresenta la stringa casuale assegnata al valore <span class="math inline">\(j\)</span> del filo <span class="math inline">\(W_i\)</span>.</p>
<p>Quindi, per confondere la tabella di verità di <span class="math inline">\(G\)</span> in modo da non rivelare alcuna informazione dati due valori di ingresso <span class="math inline">\(w_0\)</span>, <span class="math inline">\(w_1\)</span> eccetto il suo valore di uscita <span class="math inline">\(w\)</span>, nemmeno il tipo di porta logica, Alice può criptare i valori di uscita <span class="math inline">\(w_0\)</span>, <span class="math inline">\(w_1\)</span> usando i valori di ingresso confusi come chiavi, usando un dato schema di crittografia simmetrica <span class="math inline">\(\mathbb{E}\)</span>. Uso la notazione <span class="math inline">\(\mathbb{E}_{k_0,k_2}(x) = \mathbb{E}_{k_0}(\mathbb{E}_{k_1}(x))\)</span> per indicare la cifratura doppia con due chiavi date <span class="math inline">\(k_0, k_1\)</span>. Come esempio, criptiamo la tabella di verità della porta AND della figura:</p>
<p><span class="math display">\[\begin{array}{c|c|c||c}
W_0 &amp; W_1 &amp; W &amp; \text{Garbled value} \\ \hline
        w_0^0 &amp; w_1^0 &amp; w^0 &amp; \mathbb{E}_{w_0^0,w_1^0}(w^0) \\
        w_0^0 &amp; w_1^1 &amp; w^0 &amp; \mathbb{E}_{w_0^0,w_1^1}(w^0) \\
        w_0^1 &amp; w_1^0 &amp; w^0 &amp; \mathbb{E}_{w_0^1,w_1^0}(w^0)\\
        w_0^1 &amp; w_1^1 &amp; w^1 &amp; \mathbb{E}_{w_0^1,w_1^1}(w^1) \\
\end{array}\]</span></p>
<p>La GTT <span class="math inline">\(T\)</span> del gate <span class="math inline">\(G\)</span> è semplicemente l’insieme <span class="math inline">\(\left\lbrace\mathbb{E}_{w_0^j,w_1^k}(w^{G(j,k)}) \mid j,k \in \left\lbrace0,1\right\rbrace \right\rbrace\)</span> dei valori confusi, dove <span class="math inline">\(G(j,k)\)</span> corrisponde all’uscita della porta <span class="math inline">\(G\)</span> sotto ingressi <span class="math inline">\((j,k)\)</span>.</p>
<div style="page-break-after: always;"></div>
</div>
<div id="valutazione-del-garbled-circuit" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Valutazione del Garbled Circuit</h2>
<p>Una volta che Bob ha ricevuto il circuito confuso <span class="math inline">\(C\)</span> da Alice e ha ottenuto i valori confusi del suo input attraverso diversi Oblivious transfer, può valutare il circuito.</p>
<p>È importante capire che un circuito confuso differisce da un normale circuito booleano. In un circuito booleano, semantica e sintassi sono fondamentalmente le stesse: stiamo assegnando ad ogni filo due possibili valori semantici, cioè Vero o Falso, che sintatticamente denoteremo come un segnale con valori 1 o 0 rispettivamente.</p>
<p>Questi segnali erano pubblici e gli stessi segnali erano associati ad ogni filo e chiunque poteva dire dal segnale quale valore semantico aveva. Questo cambia in un circuito confuso, poiché i valori semantici di ogni segnale, eccetto quelli di uscita del circuito, sono ora segreti e i segnali variano da un filo all’altro.</p>
<p>Così, per valutare il circuito, per ogni porta <span class="math inline">\(G_i\)</span> del circuito, Bob può provare a decifrare i valori nella tabella di verità associata <span class="math inline">\(T_i\)</span> usando i valori di ingresso della porta come chiavi. Una delle voci in <span class="math inline">\(T_i\)</span> sarà poi decifrata nell’uscita del gate. Quindi sembra necessario avere un oracolo che confermi il successo della decrittazione delle voci di <span class="math inline">\(T_i\)</span>, tuttavia un trucco che descriverò in dettaglio ora, chiamato permute-and-point usato per la prima volta in <span class="citation">(Beaver, Micali, e Rogaway <a href="#ref-fval" role="doc-biblioref">1990</a>)</span> e poi spiegato chiaramente nella tesi di Phillip Rogoway <span class="citation">(Rogaway <a href="#ref-prog" role="doc-biblioref">1991</a>)</span>, permette di decidere quale voce della GTT deve essere decrittata dati gli input confusi, permettendo calcoli più veloci e impedendo comunque al valutatore di dedurre qualcosa dall’ordine delle voci della tabella di verità.</p>
</div>
<div id="permute-and-point" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Permute-and-point</h2>
<p>Questo meccanismo funziona nel seguente modo: per ogni filo di ingresso e uscita <span class="math inline">\(w_i\)</span>, Alice concatena un bit casuale <span class="math inline">\(a \in \{0,1\}\)</span> alla fine del suo valore confuso <span class="math inline">\(w^{0}_i\)</span> e concatena il suo valore inverso <span class="math inline">\(b = \overline{a} = 1 - a\)</span> alla fine di <span class="math inline">\(w^{1}_{i}\)</span>. Quindi permette di associare ciascuna delle 4 permutazioni di 2 bit a una delle entrate della GTT, senza avere alcuna correlazione tra i bit e i valori della tabella della verità non confusa. Così Alice può semplicemente ordinare la GTT secondo l’ordinamento naturale e darla a Bob che sarà quindi in grado di dedurre quale voce deve decifrare su un dato input. Per ottenere una bella rappresentazione di questo trucco, quei bit possono essere visti come una coppia di colori, come li raffiguro nella figura 2.2, in cui vediamo come la tabella di verità viene modificata per tenere conto di questo metodo.</p>
<div style="page-break-after: always;"></div>
<div class="figure">
<img src="media/02.png" alt="" />
<p class="caption">AND garbled con permute on point</p>
</div>
<p>Queste modifiche permettono a Bob di decifrare semplicemente la voce il cui indice corrisponde ai colori associati ai suoi fili di ingresso e quindi di ottenere il valore del filo di uscita e il suo colore, permettendogli di valutare ulteriormente il circuito.</p>
</div>
<div id="esempio-di-valutazione" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Esempio di Valutazione</h2>
<div class="figure">
<img src="media/03.png" alt="" />
<p class="caption">AND garbled con permute on point</p>
</div>
<p>Vediamo come si potrebbe valutare il circuito confuso rappresentato nella Figura 2.3 usando il metodo permute-and-point che abbiamo discusso sopra. Assumiamo che i valori semantici di ingresso di <span class="math inline">\((W_1,W_2,W_3,W_4)\)</span> siano <span class="math inline">\((0,0,1,0)\)</span>, il che significa che l’input confuso effettivo è <span class="math inline">\(({\color{green}\bullet}{}w_1^0,{\color{red}\bullet}{}w_2^0,{\color{red}\bullet}{}w_3^1,{\color{green}\bullet}{}w_4^0)\)</span> dove gli <span class="math inline">\(w^i_j\)</span> sono i valori casuali che Alice ha scelto quando ha confuso il circuito, come visto sopra. Assumiamo anche che Alice abbia già fornito il suo input confuso, diciamo <span class="math inline">\((W_1,W_3)\)</span>, e che Bob abbia già ottenuto il suo input confuso <span class="math inline">\((W_2,W_4)\)</span> da Alice attraverso due applicazioni di Oblivious transfer come descritto nella parte sul protocollo.</p>
<p>Quindi Bob comincerà a valutare prima la porta AND utilizzando l’ingresso <span class="math inline">\(({\color{green}\bullet}{}w_1^0,{\color{red}\bullet}{}w_2^0)\)</span>, dato che ha i colori <span class="math inline">\(\color{green}\bullet\color{red}\bullet\)</span> cercherà di decifrare la terza voce della GGT della porta AND, che funziona e quindi gli fornirà il valore confuso <span class="math inline">\({\color{green}\bullet}{}w_5^0\)</span>.</p>
<p>Poi può continuare la sua valutazione con la seconda porta, che è la porta OR. Guarda il suo ingresso <span class="math inline">\(({\color{red}\bullet}{}w_3^1,{\color{green}\bullet}{}w_4^0)\)</span> e prova a decifrare la voce corrispondente a <span class="math inline">\(\color{red}\bullet\color{green}\bullet\)</span> con le chiavi <span class="math inline">\((w_3^1,w_4^0)\)</span>, essa si decifra nel valore confuso <span class="math inline">\({\color{green}\bullet}{}w_6^1\)</span>.</p>
<p>Ora può decifrare la porta XOR finale usando l’ingresso calcolato <span class="math inline">\(({\color{green}\bullet}{}w_5^0,{\color{green}\bullet}{}w_6^1)\)</span>, decifrando così la voce <span class="math inline">\(\color{green}\bullet\color{green}\bullet\)</span> che gli fornisce il risultato finale: <span class="math inline">\(1\)</span>.</p>
<p>Bob non sa quale sia stato l’input di Alice, conosce solo l’output finale “1” e le stringhe generate casualmente <span class="math inline">\(w_1^0,w_2^0,w_3^1,w_4^0,w_5^0,w_6^1\)</span>. Egli può ancora, per esempio, dedurre dal circuito che i valori semantici di <span class="math inline">\(w_5^0\)</span> e <span class="math inline">\(w_6^1\)</span> sono opposti, tuttavia non gli permette di invertire il circuito confuso fino ai valori di ingresso di Alice.</p>
<p>Ci sono circuiti in cui non è assicurata la privacy, come per esempio un circuito che calcola la somma degli ingressi, tuttavia in questo caso di esempio, Bob - conoscendo i suoi valori semantici di ingresso - può semplicemente limitare gli ingressi di Alice a un sottoinsieme dei possibili ingressi, ma non può determinare in modo univoco i reali valori di ingresso di Alice.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references hanging-indent">
<div id="ref-fval">
<p>Beaver, D., S. Micali, e P. Rogaway. 1990. <em>The Round Complexity of Secure Protocols</em>. STOC ’90. New York, NY, USA: Association for Computing Machinery. <a href="https://doi.org/10.1145/100216.100287">https://doi.org/10.1145/100216.100287</a>.</p>
</div>
<div id="ref-prog">
<p>Rogaway, Micali, P. 1991. «The round complexity of secure protocols (Doctoral dissertation, Massachusetts Institute of Technology, Dept. of Electrical Engineering and Computer Science).»</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="secure-multi-party-computation.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="analisi.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"search": {
"engine": "lunr",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
