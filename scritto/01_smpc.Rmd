# Secure multi-party computation
Secure multi-party computation (SMPC) è una sotto categoria della crittografia con l'obiettivo di creare metodi di calcolo congiunto di una funzione sugli input privati di 2 o più parti coinvolte.

A differenza dei compiti crittografici tradizionali, dove la crittografia assicura la sicurezza e l'integrità della comunicazione o dell'archiviazione e l'avversario è esterno al sistema dei partecipanti, la crittografia in questo modello protegge la privacy dei partecipanti l'uno dall'altro.

Siamo in un periodo in cui i dati sono sempre più centrali e oggetto di interesse per le aziende diventando un nuovo metodo di guadagno. La monetizzazione dei dati è oggi il modello di business primario comune a molte delle più grandi aziende, e la priorità di tante altre.

L’applicazione di un simile modello di business richiede tuttavia la raccolta di grandi quantità di dati, e il successo è tanto più significativo quante più correlazioni e rapporti di casualità sia possibile trovare combinando diverse fonti dati, si devono però considerare le problematiche.

Il sottoprodotto di questo processo è infatti una possibile violazione della privacy individuale, avendo le aziende molte nostre informazioni personali il loro possesso.

Si sono pensate allora soluzioni in cui sia possibile utilizzare fonti dati diverse senza la necessità di centralizzare l'informazione, garantendo che nessuna informazione sia rivelata dall'operazione. Queste sono le premesse della Secure multiparty computation (SMPC). In altri termini, saremmo così in grado di consentire ai Data Scientist e Data Analyst di operare sui dati senza il bisogno di esporli o spostarli dalla loro sede di storage. 
\newpage

## Panoramica

In una SMPC un dato numero di partecipanti $p_1, p_2, ..., p_N$, ognuno dei quali ha dei dati privati $d_1, d_2, ..., d_N$. I partecipanti vogliono calcolare il valore di una funzione pubblica con i loro dati privati: $F(d_1, d_2, ..., d_N)$ mantenendo i loro input segreti.


Per esempio, supponiamo di avere tre parti Alice, Bob e Charlie, con i rispettivi input x, y e z che denotano i loro stipendi. Vogliono scoprire il più alto dei tre stipendi, senza rivelare all'altro quanto guadagna ognuno di loro. Matematicamente, questo si traduce in un calcolo: $F(x, y, z) = max(x, y, z)$

Se ci fosse una parte esterna fidata (diciamo che hanno un amico comune, Tony, che deve mantenere i segreti delle parti), ognuno potrebbe dire il proprio stipendio a Tony, lui potrebbe calcolare il massimo e dire quel numero a tutti loro.

L'obiettivo di SMPC è di progettare un protocollo in cui, scambiando messaggi solo tra di loro, Alice, Bob e Charlie possono ancora calcolare $F(x, y, z)$ senza rivelare chi fa cosa e senza dover dipendere da terzi. Non dovrebbero saperne di più, impegnandosi nel loro protocollo, di quanto saprebbero interagendo con un Tony incorruttibile e perfettamente degno di fiducia.

In particolare, tutto ciò che le parti possono sapere è ciò che loro possono apprendere dall'output e dal loro stesso input. Così nell'esempio precedente, se l'output è $z$, allora Charlie impara che il suo $z$ è il valore massimo, mentre Alice e Bob imparano (se $x$, $y$ e $z$ sono distinti), che il loro input non è uguale al massimo, e che il massimo è uguale a $z$. Lo scenario di base può essere facilmente generalizzato ai casi in cui le parti hanno diversi input e output, e la funzione fornisce valori diversi alle diverse parti.

\newpage

Un protocollo di calcolo sicuro multipartitico deve offrire alcune garanzie di sicurezza, persino se alcune delle parti fossero in collusione o cercassero di violarne le regole:

- **Input Privacy**: Nessuna delle parti corrotte (o suo sottoinsieme) deve essere in grado di derivare alcuna informazione sui dati appartenenti alle altre parti, a eccezione di quanto rivelato dal risultato dell’operazione
- **Correctness**: Nessuna delle parti corrotte (o suo sottoinsieme) deve essere in grado di indurre una parte onesta a produrre un risultato errato.

## Garanzie di sicurezza

Grazie alle SMPC le parti coinvolte nelle computazioni non hanno bisogno di fidarsi reciprocamente, anche qualora alcune di queste intendano collaborare ai danni delle altre o quando reti e macchine siano state compromesse a loro insaputa in quanto nessuna informazione viene rivelata alle altre parti. Abbiamo quindi i seguenti aspetti positivi:

- Assenza di una necessaria terza parte fidata per mantenere i dati sicuri.
- Nessun compromesso di Privacy-vs-Utility, poiché non dobbiamo perturbare alcun dato per tutelarne la privacy.
- GDPR compliance persino per interazioni tra aziende europee, americane e asiatiche, perché i dati non lasciano mai i confini.
- Protezione di un segreto, che può essere utilizzato per svolgere operazioni senza mai crearlo effettivamente

Ovviamente non mancano gli aspetti negativi:

- Costo computazionale elevato, richiesto per la generazione dei numeri casuali che garantiscono la sicurezza nei calcoli.
- Costo comunicativo elevato, richiesto dal network per la condivisone con i partecipanti.
- Network bound

\newpage

## Two-party computation

Una particolare sotto-categoria delle SMPC è la Two-party computation. Questa categoria descrive uno scenario in cui 2 parti parti comunicano tra di loro per la risoluzione di un problema senza scambiarsi informazioni sensibili e senza l'utilizzo di una terza parte fidata. 

Lo scenario a due parti è particolarmente interessante, non solo dal punto di vista delle applicazioni, ma anche perché si possono applicare tecniche speciali nel contesto a due parti che non si applicano nel caso a più parti. Infatti, il calcolo sicuro a più parti è stato presentato per la prima volta nell'impostazione a due parti. Il lavoro originale è spesso citato come proveniente da uno dei due articoli di Yao; anche se gli articoli non contengono effettivamente quello che ora è noto come il Yao's garbled circuit protocol.

Il protocollo di base di Yao è sicuro contro gli avversari semi-onesti ed è estremamente efficiente in termini di numero di passaggi, che è costante, e indipendente dalla funzione obiettivo che viene valutata. La funzione è vista come un circuito booleano, con ingressi in binario di lunghezza fissa. Un circuito booleano è un insieme di porte collegate con tre diversi tipi di fili: fili di ingresso al circuito, fili di uscita al circuito e fili intermedi. Ogni porta riceve due fili d'ingresso e ha un singolo filo d'uscita che potrebbe essere fan-out (cioè essere passato a più porte al livello successivo). La semplice valutazione del circuito viene fatta valutando ogni porta a turno; assumendo che le porte siano state ordinate topologicamente. Il gate è rappresentato come una tabella di verità tale che per ogni possibile coppia di bit (quelli provenienti dal gate dei fili di ingresso) la tabella assegna un unico bit di uscita; che è il valore del filo di uscita del gate. I risultati della valutazione sono i bit ottenuti nei fili di uscita del circuito.

Yao ha spiegato come confondere un circuito (nascondere la sua struttura) in modo che due parti, mittente e ricevitore, possano imparare l'uscita del circuito e nient'altro. Ad un alto livello, il mittente prepara il circuito confuso e lo invia al ricevitore, che ignaro valuta il circuito, imparando le codifiche corrispondenti all'uscita sua e del mittente. Poi si limita a rimandare le codifiche del mittente, permettendo a quest'ultimo di calcolare la sua parte di output. Il mittente invia la mappatura dalle codifiche di uscita dei ricevitori ai bit al ricevitore, permettendo a quest'ultimo di ottenere la propria uscita. Nel capitolo successivo andremo più in profondità spiegando dettagliatamente la logica di funzionamento.