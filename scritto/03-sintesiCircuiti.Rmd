# La sintesi dei circuiti

Nel capitolo precedente abbiamo discusso dell'importanza della presenza di un circuito logico all'interno del protocollo creato da Yao. La scelta di un circuito efficiente rende la computazione e i tempi di calcolo delle operazioni non elevati. Ciò che rende efficace la scelta è trovare il giusto bilanciamento tra numero di input che le 2 parti coinvolte devono immettere nel circuito e, nel caso di un dominio multivalore, scegliere un dominio non troppo elevato che andrebbe ad immettere, per ogni valore di input, troppi valori che porterebbero ad aumentare i costi totali del circuito.

La scelta di questi circuiti viene facilitata dall'utilizzo di strumenti chiamati *sintetizzatori*, questi tool sono stati creati per andare a ridurre le dimensioni dei circuiti dati loro in ingresso. All'interno di questo lavoro sono stati utilizzati 2 tool differenti: **MVSIS** e **ABC**, entrambi sono stati sviluppati nel tempo dall'università di Berkley, essi contengono diversi metodi di sintesi capaci di andare a eliminare nodi e ridondanze superflue nei circuiti e sintetizzare il circuito andandone a cambiare radicalmente la struttura interna de i nodi.

\newpage

## MVSIS

MVSIS è il primo tool in grado di manipolare circuiti con una logica multivalore. Per la sua creazione si è preso come modello **SIS**, un tool sviluppato e specifico per la logica binaria, cercando di mantenerne simile la logica di funzionamento.

### Design specification

Un circuito multivalore (MV circuit) può essere dato come valore di input a **MVSIS** tramite l'apposito comando (`read_blifmv`), oltre a circuiti multivalore possono essere dati in input anche circuiti binari. Internamente, la rappresentazione del progetto è una rete di nodi MV; ogni nodo rappresenta una rappresenta una funzione MV con una singola uscita a più valori. Un'importante distinzione con alcuni altri metodi multivalore è che ogni variabile del nodo può avere un dominio diverso. L'intervallo per la variabile $y_k$ è rappresentato dall'insieme $P_k=\{0,1,...,p_k -1 \}. La funzione il cui esito dà UN SET dei mintermi (Una sola uscita con 0 o 1) per i quali $f_k = i$ (la funzione al nodo $k$ è uguale al valore $i$ ) è chiamata *i-set* della funzione $f_k$ e viene memorizzata in forma SOP (Somma di prodotti). Nel caso di logica a 2 valori, l'insieme 0 corrisponde all'off-set e l'insieme 1 all'on set. Una variabile MV yk è associata all'uscita del nodo k. Un margine congiunge $k$ a $j$ se uno qualsiasi degli i-set di $j$ dipende esplicitamente da $y_k$. La rete ha un insieme di ingressi primari (che possono essere tutti a più valori) e un insieme di nodi di ingressi primari.

### Semplificazione dei nodi

L'i-set (uno per ogni valore di output) di un nodo multivalore può essere semplificato con 2 comandi:

- SIMPLIFY
- FULLSIMP

FULLSIMP tra le 2 opzioni è quella che garantisce una semplificazione più efficace.Utilizza il CODC (Compatible Observability Don't Cares) e MV-image computation. Ogni i-set del nodo è poi semplificato da ESPRESSO-MV utilizzando i valori ricavati dalle 2 tecniche precedenti.

\newpage

### Kernel e Cube Extraction

Un altro importante step nell'ottimizzazione del circuito consiste nell'applicare metodi algebrici per estrarre nuovi nodi che hanno divisori comuni per altri nodi. Si sono sviluppate nuove tecniche algebriche per la logica MV che trattano uniformemente le variabili binarie e multi-valore. Esse includono metodi per
trovare sottoespressioni comuni, divisione semi-algebrica, decomposizione di una rete multi-valore e fattorizzazione di una forma SOP. I comandi rilevanti e le brevi descrizioni delle loro capacità sono elencati di seguito.

1. **FX**: estrae buoni divisori comuni e crea nuovi nodi nella rete, reimpostando altri nodi in termini di questi.
2. **Decomp**: fa una completa fattorizzazione multivaloriale degli i-sets di ogni nodo e suddivide i nodi secondo queste fattorizzazioni. Dopo questo, **resub**, usando la divisione algebrica multivalore, può essere eseguita per eliminare i fattori duplicati.

### Altri comandi per la manipolazione dei nodi

1. **Collapsing**: converte l'intera rete multilivello in modo che le forme SOP per ogni uscita siano in termini di soli ingressi primari. Così il numero di nodi nella rete sarà esattamente il numero di uscite primarie.
2. **Merging**: Prende tutti i nodi e forza un'unione creando un singolo nodo multi-valore costruendo in *i-set* per ogni combinazione di valori creata. Se ci sono più *i-set* creati uguali vengono uniti in un singolo nodo.
3. **Encoding**: è come l'inverso del merging di funzioni binarie. Cerca di trovare una buona codifica binaria per ogni variabile multi-valore nella rete, compresi gli ingressi e le uscite primarie. Alla fine, ogni segnale è codificato come un segnale binario. Quindi un file binario può essere scritto. Formato da 2 fasi:
   1. Inizia dagli ingressi e per ogni nodo, determina se uno dei suoi fanin può essere usato per codificare parzialmente il nodo.
   2. inizia dalle uscite e in ordine topologico inverso lavora a ritroso fino agli ingressi primari. Ad ogni nodo, le sue uscite sono codificate utilizzando le informazioni su come sono utilizzati i suoi fanout
4. **Pair decoding**: Simile al merging ma utilizza un altro modo per scegliere quali modi unire.
5. **Bi-decomposition**: crea dei nodi multi-valore intermedi. Prende una rete MV appiattita o parzialmente appiattita e ne genera un'altra composta da porte MAX e MIN multi-valutate a due ingressi e da iterali multi-valutati. Vengono sfruttate sia l'incompletezza della specifica iniziale che le flessibilità generate nel processo di composizione.

## ABC

ABC è un sistema software in sviluppo per la sintesi e la verifica di circuiti logici sequenziali binari che appaiono in progetti hardware. ABC combina un'ottimizzazione logica scalabile basata su And-Inverter Graphs (AIGs), una mappatura tecnologica basata su DAG per tabelle di look-up e celle standard e algoritmi innovativi per la sintesi e la verifica sequenziale.

Questo programma nasce dalle esperienze assimilate dall'uso di SIS, VIS e MVSIS.
Questi sistemi non forniscono un ambiente di programmazione flessibile per implementare le recenti innovazioni. In particolare, l'ambiente SIS è obsoleto e piuttosto inefficiente nella gestione di grandi circuiti. VIS, progettato come strumento di verifica formale per specifiche multi-valore, non fornisce abbastanza flessibilità per la sintesi binaria. MVSIS nonostante il suo ampio utilizzo: 

- Le strutture dati e gli algoritmi di base di MVSIS possono essere resi considerevolmente più semplici e facili da usare assumendo reti binarie,
- Un posto centrale nel nuovo sistema dovrebbe essere dato a una nuova struttura dati, le AIG (reti logiche multilivello composte da AND e inverter a due ingressi), che promette miglioramenti nella qualità e nel tempo di esecuzione della sintesi e della verifica.

La comprensione di queste problematiche ha spinto a ri-sviluppare i pacchetti di base di MVSIS risultando in un nuovo ambiente di programmazione chiamato ABC. Come suggerisce il nome, l'obiettivo primario è quello di mantenere strutture di dati semplici e flessibili per una vasta gamma di applicazioni.

L'obiettivo del progetto ABC è quello di fornire un'implementazione pubblica degli algoritmi di sintesi combinatoria e sequenziale allo stato dell'arte e, allo stesso tempo, creare un ambiente open-source, in cui tali applicazioni possano essere sviluppate e confrontate. La versione attuale di ABC può ottimizzare/mappare/realizzare progetti industriali a livello di gate con 100K porte e 10K elementi sequenziali cont tempi di calcolo non superiori al minuto in un computer moderno.

### Sintesi combinatoria

I metodi di logica combinatoria utilizzati da ABC all'interno dei suoi script (resyn e resyn2) sono tipicamente 10-100 volte più veloci se comparati agli script utilizzati all'interno di SIS o MVSIS.

In ABC, i confini dei nodi sono inizialmente distrutti dall'hashing strutturale (comando _strash_), che trasforma una rete logica in un AIG. I confini possono essere ricreati su richiesta usando il comando _renode_, che può essere visto come un inverso del comando SIS _eliminate_. Nel flusso di sintesi presentato sopra la logica viene trasformata a livello di AIG senza creare nodi.

- **Balance**: prende come ingresso un AIG e lo bilancia.
- **Cleanup**: Rimuove i nodi logici che non sono a ventaglio in PO e latches. 
- **Collapse**: Collassa tutto il circuito ad una rete ad un solo livello. Le funzioni dei nodi sono rappresentate utilizzando le BDD. 
- **Dsd**: Applica la decomposizione disjoint-support utilizzando l'algoritmo di Bertacco/Damiani [@ICCAD97]. 
- **fx**: Rileva la logica di condivisione estraendo i divisori a due cubi e i divisori a due lettere a un cubo usando l'algoritmo di Rajski/Vasudevamurthi [@TCAD92].
- **Multi**: Espande l'AIG a due ingressi in una rete di porte AND a più ingressi.
- **refactor**: Esegue il collasso iterativo e il refactoring dei coni logici nell'AIG, che cerca di ridurre il numero di nodi AIG e il numero di livelli logici.
- **renode**: Assume che l'input sia un AIG. Crea i confini dei nodi in questo AIG e collassa la logica intermedia per formare nodi più grandi.
- **rewrite**: Assume che l'input sia un AIG. Crea i legami tra i nodi in questo AIG e collassa la logica intermedia per formare nodi più grandi.
- **rr**: Esegue la rimozione della ridondanza per le AIG.
- **strash**: Trasforma la rete corrente in un AIG tramite un livello di hashing strutturale. L'AIG risultante è una rete logica composta da porte AND a due ingressi e invertitori rappresentati come attributi complementari sui bordi. L'hashing strutturale è una trasformazione puramente combinatoria, che non modifica il numero e le posizioni delle porte.
- **sweep**: sweep classico applicabile alla rete logica corrente che risulta in una rete logica. Sweep esegue i seguenti compiti: rimuove i nodi dangling (nodi senza fanout), collassa i buffer e gli inverter nei loro fanout, propaga le costanti, e rimuove i fanin duplicati. Sweep non può essere applicato a un AIG perché un AIG è strutturalmente hashed e quindi non ha buffer, invertitori e nodi costanti non propagati. Per rimuovere i nodi dandling nella rete logica, usate cleanup.

\newpage

### Sintesi sequenziale

La sintesi sequenziale trasforma la rete corrente modificando la sua logica insieme agli elementi di memorizzazione (latches o flip-flops), se presenti. La rete risultante può avere una codifica di stato e uno spazio di stato diversi rispetto alla rete originale, ma le due reti sono sequenzialmente equivalenti (cioè, partendo dagli stati iniziali, per le stesse sequenze di vettori d'ingresso, producono sequenze identiche di vettori d'uscita).

- **Cycle**: Simula la rete sequenziale con un input casuale e aggiorna il suo stato attuale.
- **init**: Ripristina gli stati iniziali di tutte le porte della rete corrente.
- **lcorr** - Implementazione suddivisa di registro-corrispondenza usando l'induzione semplice. Rileva e fonde registri sequenzialmente equivalenti.
- **retime**: Implementa diversi tipi di retiming: 
   - most forward;
   - most backward;
   - minimum-register;
   - minimum-delay euristico;
   - delay-optimal retiming [@ICCD_1997]

   Le porte sono condivise in modo ottimale attraverso gli archi di fanout quando il circuito è trasformato dall'AIG in una rete logica. Il calcolo degli stati iniziali dopo il retiming è ridotto a un problema SAT, che viene risolto usando MiniSat.
- **scleanup**: Esegue la pulizia sequenziale (rimuove i nodi e le latches che non sono a fanout).
- **ssw**: Implementa la segnali corrispondenti usando l'induzione K-step. Rileva e fonde i nodi sequenzialmente equivalenti.
- **undc**: Si può utilizzare questo comando prima di eseguire la verifica sequenziale, per convertire i registri con gli stati iniziali don't-care in registri con uno stato iniziale costante-0.
- **xsim**: Esegue la simulazione con valore $X$ della rete sequenziale corrente.