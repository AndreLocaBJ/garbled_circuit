\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[italian,]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{pmboxdraw}
\usepackage{float}
\usepackage[square,numbers]{natbib}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[shorthands=off,main=italian]{babel}
\else
  % load polyglossia as late as possible as it *could* call bidi if RTL lang (e.g. Hebrew or Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[]{italian}
\fi
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\author{}
\date{\vspace{-2.5em}}

\begin{document}

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{introduzione}{%
\chapter*{Introduzione}\label{introduzione}}
\addcontentsline{toc}{chapter}{Introduzione}

L'argomento principale di questa tesi è una particolare sotto categoria della crittografia, ovvero la Secure Multi-Party computation (SCM). Il protocollo di Secure Multi-party Computation si identifica come l'approccio maggiormente impiegato nella letteratura studiata per consentire a due o più parti di eseguire calcoli generici in modo collaborativo, mantenendo segreto il proprio input e condividendo solo il risultato finale.

Un particolare approfondimento svolto è stato quello relativo alla ``Two party computation'' e come renderla più efficiente.
Si tratta di una particolare sotto-categoria delle SMPC che descrive uno scenario in cui due parti comunicano tra di loro per la risoluzione di un problema, senza però scambiarsi informazioni sensibili e senza ricorrere all'utilizzo di una terza parte fidata. \citep{hemenway2014achieving}

Una tecnica, largamente usata in questo ambito, si basa sulla sintesi di Garbled Circuits (GC) ed è stata proposta per la prima volta da Yao. Questo tipo di circuito, nelle sue varie fasi, permette di raggiungere l'obbiettivo di privacy sopra citato mediante l'utilizzo di un circuito virtuale in cui gli utenti inseriscono i propri input crittografati.

Per migliorare l'efficienza di questo tecnica e sfruttare i protocolli SMC in applicazioni pratiche, come l'esternalizzazione del calcolo in ambienti non attendibili, sono state introdotte numerose ottimizzazioni. In genere i circuiti utilizzati sono basati sulla logica booleana. Recentemente è stato proposto un protocollo di Secure Multi-party Computation basato invece sulle logiche multi valore. In questa tesi analizziamo, per la prima volta, l'implementazione di tecniche Multiple Valued Logic per la progettazione di Garbled Circuits, discutendo il loro impatto sui costi.

In particolare la finalità di questa tesi è quella di studiare se, applicando un circuito con logica multi valore, sia possibile ottenere una riduzione dei costi operazionali per conseguire una miglior performance del protocollo. Prima di intraprendere questa analisi è stato necessario soffermarsi su quali fossero i metodi più efficaci per ottenere una corretta conversione dei circuiti da binari a multi valore, che ci consenta di ottenere una buona minimizzazione dei costi totali e che allo stesso tempo ci renda possibile una comparazione dei risultati con i dati forniti dalla letteratura. \citep{gao2002optimization}

Un ulteriore strumento analizzato ed utilizzato è la sintesi dei circuiti, che viene applicata sia ai circuiti booleani che a quelli multi valore, in modo tale da ripulire la struttura da ridondanze e minimizzare il numero di porte il più possibile. Gli strumenti di sintesi in nostro possesso hanno giocato un ruolo fondamentale ai fini dell'analisi, in quanto i tool disponibili per gestire la logica multi valore non sono del tutto adatti ad affrontare questi tipi di nuovi problemi in quanto non implementati o aggiornati nel tempo. Per far fronte a questa carenza, la direzione della tesi si è spostata verso un approccio ``ibrido''.

L'obbiettivo del metodo proposto è quello di poter andare a utilizzare e valorizzare i punti di forza di entrambe le logiche. Nel caso della logica multi valore, riducendo il numero degli input che le parti devono utilizzare e limitando drasticamente la dimensione del dominio, è stato possibile ridurre i costi computazionali del processo. Dall'altra parte invece, nel caso della logica booleana, sfruttando gli strumenti di sintesi più evoluti ed implementati nel tempo è stato possibile ridurre notevolmente le dimensioni della struttura del circuito, riducendo ulteriormente i costi computazionali del processo.

I risultati finali della tesi hanno dimostrato che l'approccio ibrido può essere considerato interessante in quanto, nella maggior parte dei casi, è stato possibile notare una riduzione sostanziale dei costi del circuito in esame rispetto ad un normale circuito booleano sintetizzato

\newpage

All'interno del primo capitolo di questa tesi viene introdotto il cambiamento a livello storico ed economico del valore dei dati degli utenti, che li ha resi un business primario per le aziende, portando alla monetizzazione di essi. Questo processo ha reso evidente una possibile problematica relativa alla violazione della privacy individuale della persona in quanto veniva attuato un massivo movimento di dati. Queste nuove dinamiche, le quali hanno definito le basi e le premesse dell'attuale processo per la sicurezza chiamato Secure multiparty computation (SMPC), hanno reso possibile operare sui dati senza esporli o spostarli dalla sede di partenza. In questo capitolo viene analizzato il funzionamento di questo processo atto ad elaborare metodi di calcolo congiunto di una funzione sugli input privati di due o più parti coinvolte proteggendo la privacy dei partecipanti l'uno dall'altro.
Una volta definito il protocollo lo studio tratta quelle che vengono definite ``garanzie di sicurezza'' che rendono quest'ultimo efficace, i modelli di mondo reale/ideale al quale il paradigma viene associalo e i possibili avversari alla sicurezza che potrebbero partecipare a questo sistema.

Lo studio si focalizza in particolare su una sottocategoria dell'SMPC: la two party computation,\\
Essa descrive uno scenario in cui due parti parti comunicano tra di loro per la risoluzione di un problema, senza però scambiarsi informazioni sensibili e senza ricorrere all'utilizzo di una terza parte fidata. Questo scenario risulta analizzato per la prima volta tramite il Yao's garbled circuit protocol. \citep{yao1982protocols}

In seguito nel capitolo è esposta la struttura di questo tipo di circuiti, i quali risultano efficienti in quantità di passaggi e in sicurezza della struttura in quanto sono composti da circuiti booleani che permettono di ``confondere'' il circuito in modo che i partecipanti possano dedurre solo gli output senza venire a conoscenza di altri dati del sistema.

\newpage

Il secondo capitolo si sviluppa partendo dall'utilizzo di un esempio per giungere ad una comprensione più approfondita del ``Yao Garbled Circuit''. Tramite questa dimostrazione è reso chiaro il metodo tramite il quale questo circuito è in grado di garantire un buon livello di sicurezza: i partecipanti modellano la funzione come un circuito booleano, e in seguito il mittente confonde i valori del circuito. Come conseguenza viene illustrato il protocollo chiamato oblivius tranfer, tramite il quale il mittente trasmette un pezzo di informazione al ricevitore, ma rimane ignaro di quale pezzo di informazione sia stato trasmesso, in questo modo il mittente non sarà in grado di conoscere l'input del ricevitore, conservando così la privacy dei dati. \citep{4568207}

In seguito all'esempio sopracitato, il capitolo necessita di un'ulteriore focus cruciale dedicato al garbling delle porte logiche e della loro tabella di verità. In questa sezione sono descritte le modalità con le quali è possibile confondere la tabella di verità e, alla fine del processo, criptare i valori di uscita adottando lo schema della crittografia simmetrica.

Una volta analizzate queste tematiche viene discussa la differenza tra un circuito booleano e un circuito confuso, in quanto questi due tipi di circuiti presentano delle differenze strutturali fondamentali riguardanti la semantica e la sintassi.

Il processo di confusione del circuito presenta un'ulteriore problematica: come avere la conferma del successo della decrittazione del circuito?. Per questo motivo viene analizzato di seguito l'espediente chiamato ``permute and point'' andandone a sviscerare la struttura e il funzionamento, per poi concludere il capitolo con un ulteriore esempio del permute and point in grado di mostrare effettivamente il funzionamento di questa tecnica.

\newpage

Il terzo capitolo esordisce con una tematica molto importante dell'informatica in generale: l'efficienza del circuito. Applicando questa questione al nostro circuito confuso, questo capitolo è dedicato a due tool che vengono utilizzati come sintetizzatori, rispettivamente chiamati MVSIS e ABC. La funzione specifica di questi tool è quella di andare a ridurre quanto possibile le dimensioni dei circuiti dati loro in ingresso in modo da diminuire il costo totale dei circuiti eliminando nodi, ridondanze e inoltre cambiando e sintetizzando la struttura dei nodi. Nonostante entrambi abbiano lo stesso obbiettivo, essi lavorano utilizzando comandi e strumenti diversi.

Proseguendo nello sviluppo del capitolo si analizza per primo il tool MVSIS, descrivendone la struttura derivante dal tool SIS. MVSIS è stato implementato in modo tale da manipolare i circuiti con una logica detta ``logica multi valore''. Come verrà dettagliatamente descritto tramite esempi, esistono numerosi comandi in grado di svolgere funzioni sul circuito, tra queste quella di sintetizzare, di ottimizzare il circuito e molte altre per manipolare la struttura dei nodi. Oltre all'utilizzo dei sintetizzatori viene anche presentato un altro metodo che consiste nell'applicare metodi algebrici al fine di estrarre nuovi nodi che hanno divisori comuni per altri nodi con lo scopo di trovare sottoespressioni comuni, applicare una divisione semi-algebrica, attuare la decomposizione di una rete multi-valore e la fattorizzazione di una forma SOP.

In seguito, è presente l'analisi del tool ABC, che viene presentato come un successore di SIS, VIS e MVSIS., in quanto nato e creato con lo scopo di mantenere strutture di dati semplici e flessibili in modo da poter essere impiegate da una vasta gamma di applicazioni. Viene considerato un successore in quanto creato prendendo come base le esperienze di utilizzo dei tre tool sopracitati, i quali presentavano per ogni caso delle inadeguatezze differenti. Per meglio spiegare i funzionamenti di ABC, esso, nello svolgimento del capitolo, è stato messo a confronto con quello di MVSIS, evidenziandone le differenze ed esplicando quali sono i comandi utilizzabili nel sistema di ABC. \citep{manual2006quick}
Al termine del confronto viene spiegata la logica e i comandi che agendo all'unisono danno forma alla sintesi sequenziale. \citep{chai2003mvsis}

\newpage

Nel quarto capitolo si entra nel vivo della sperimentazione ed analisi convertendo in codice tutto ciò che è stato appreso dalla letteratura e dal lavoro di ricerca svolto nei capitoli precedenti. In particolare, nella prima parte del capitolo, l'attenzione è focalizzata sul testare l'efficacia dell'utilizzo di un multi valore rispetto all'utilizzo di un circuito booleano. Per poterli mettere a confronto viene presentata una ricerca sulle modalità esistenti finalizzate ad eseguire una conversione che però non vada ad intaccare la funzionalità del circuito. Questa conversione permetterà, tramite l'analisi sviluppata durante lo svolgersi del capitolo, di andare ad individuare quale dei due risulti essere più efficace e conveniente.

Il capitolo prosegue approfondendo le caratteristiche che competono la logica multi valore, andando a delineare quali sono la potenzialità che potrebbero risultare vantaggiose rispetto alla logica di un circuito booleano.
In seguito a questa analisi è presentato un focus riguardante i circuiti binari. Il motivo di tale approfondimento risulta chiaro dal momento che, per testare la tesi, è stato necessario sviluppare una tecnica di conversione dei circuiti binari di partenza senza snaturarne la logica.

Una volta stabiliti i termini di questa conversione l'attenzione dello studio si sposta sulla ricerca di un nuovo dominio multi valore che fosse adatto all'analisi ma allo stesso tempo conveniente in termine di costi.
Tutte queste operazioni svolte sui circuiti hanno portato con se la necessità di identificare un nuovo formato in grado di rappresentarli senza andarne a modificare la struttura. Il capitolo prosegue dunque con un'analisi approfondita di PLA (il formato selezionato per i circuiti binari), introducendo quindi l'elemento ``don't care`` che verrà sviluppato durante il proseguimento dello studio e applicato all'analisi svolta.

Oltre a PLA viene introdotto ed analizzato anche il formato blmf (sviluppato per i circuiti multi valore), necessario in quanto PLA non era sufficiente in quanto funzionale solo alla logica dei circuiti binari.
Per implementare la conversione dei circuiti in analisi e renderli ready to use, viene inoltre utilizzato il linguaggio di programmazione Python.

Una volta approfonditi tutti questi argomenti il capitolo prosegue applicando la sintetizzazione dei circuiti risultanti mediante MVSIS E ABC, implementando e automatizzando i processi per poi valutare in fine i costi effettivi dei circuiti messi a confronto.

\newpage

Il quinto capitolo di questa tesi contiene al suo interno i risultati sperimentali derivati dall'analisi svolta nei capitoli precedenti mirata a valutare se il nuovo approccio sviluppato potesse essere considerato una alternativa possibile o vincente rispetto alle proposte già presenti in letteratura.

Il capitolo mostra come la prima analisi sia stata svolta scegliendo l'approccio classico della logica binaria per provare ad applicarlo a quella multi valore, usando quindi MVSIS, al termine ritenuto non funzionale per due motivi: la mancanza di replicabilità di alcuni comandi in questo sistema e lo scarso sviluppo che il programma ha avuto nel tempo che lo rendono meno agile al fine dei calcoli e del suo utilizzo. L'analisi in questo senso ha mostrato come i costi vengono notevolmente abbassati nel caso del booleano mentre in quello multi valore rimangono più elevati. poichè la sintesi sui circuiti binari è nettamente più sviluppata e sono stati scoperti metodi di sintesi più efficaci rispetto a quelli studiati per una logica multi valore.

Proseguendo nelle analisi del capitolo è stato possibile appurare che, inizialmente il costo del circuito multi valore possiede dei costi più bassi per via del minor numero di input, ma che la logica binaria può appoggiarsi a degli strumenti di sintesi più sviluppati. Per questo motivo la sperimentazione procede provando ad applicare ABC.

La parte finale del capitolo parte del capitolo si focalizza dunque sull'utilizzo di questo tool. I circuiti vengono convertiti da multi valore a binari in modo da poter applicare gli algoritmi di sintesi di ABC i quali risultano più efficienti e sviluppati, generando però come output un circuito binario.

\newpage

Il capitolo finale presenta una approfondita analisi derivata dai risultati sperimentali. Essi mettono in luce come l'utilizzo della logica multi valore all'interno dei circuiti potrebbe rivelarsi molto interessante in termini di riduzione dei costi, ma, nonostante questo, sia molto difficoltoso sviluppare un calcolo con MVSIS a causa dello sviluppo del tool troppo datato. Dall'altra parte invece il tool ABC, che risulta essere molto più sviluppato e all'avanguardia, accetta in ingresso circuiti multi valore, ma, per poter fare questo, nel suo motore di sintesi, essi vengono convertiti in circuiti booleani.

I calcoli effettuati hanno messo in luce come il miglior approccio applicabile sia quello ibrido, in quanto l'applicazione della logica multi valore dimezza i valori di imput e riduce drasticamente la dimensione del dominio, e, tramite ABC con la sua conversione interna booleana del circuito multi valore creato, i calcoli sono facilitati dalla continua evoluzione e dal continuo aggiornamento del tool e dei suoi algoritmi di sintesi.

\hypertarget{secure-multi-party-computation}{%
\chapter{Secure multi-party computation}\label{secure-multi-party-computation}}

La Secure multi-party computation (SMPC) è una sottocategoria della crittografia che si pone come obiettivo quello di elaborare metodi di calcolo congiunto di una funzione sugli input privati di due o più parti coinvolte.

A differenza dei compiti crittografici tradizionali, secondo i quali la crittografia ha come fine ultimo quello di garantire la sicurezza e l'integrità della comunicazione o dell'archiviazione, e l'avversario è esterno al sistema dei partecipanti; la crittografia del modello informatico che andremo di seguito ad analizzare ha come finalità quella di proteggere la privacy dei partecipanti l'uno dall'altro.

Ci troviamo in un periodo storico in cui i dati, col passare degli anni, stanno diventando un elemento sempre più centrale per le dinamiche economiche ed informatiche e, in quanto tali, nuovo oggetto di interesse per le aziende. Il massivo incremento della loro importanza in campo economico e informatico trova una spiegazione nel cambiamento/ incremento della loro funzione. Se infatti inizialmente i dati venivano considerati come semplici ``informazioni'' relative agli utenti, attualmente essi si sono evoluti e trasformanti in potenziali nuovi metodi di profitto.

Questo processo di cambiamento della funzione e del valore dei dati ha portato nel tempo alla nascita di un nuovo modello di business primario basato prettamente sulla monetizzazione delle informazioni relative agli utenti. Questo modello di business è attualmente comune a molte delle più grandi aziende ed è diventato priorità di molte altre.

Per fare in modo che l'applicazione di un simile modello di business risulti efficace è necessario tuttavia effettuare la raccolta di grandi quantità di dati: ne consegue che il successo di tale operazione sarà tanto più significativo quante più correlazioni e rapporti di casualità sarà possibile trovare combinando diverse fonti dati. E' necessario tuttavia considerare tutte le problematiche derivanti da questa nuova dinamica.

Uno dei sottoprodotti potenzialmente rischiosi di questo processo è, ad esempio, la possibile violazione della privacy individuale della persona in quanto le aziende, incrementando la quantità di dati, possiederanno una grande quantità di informazioni personali relative ai loro utenti.

Per far fronte a questa eventuale problematica sono state studiate e sviluppate molteplici soluzioni nelle quali sia possibile utilizzare fonti dati diverse, senza però dover necessariamente centralizzare l'informazione. Questa tecnica fa in modo che la privacy individuale degli utenti venga protetta e garantisce che nessuna informazione venga rivelata a terzi nel corso delle operazioni.

Le nuove dinamiche relative alla sicurezza dei dati stileranno dunque le basi e le premesse dell'attuale processo per la sicurezza chiamato Secure multiparty computation (SMPC). In altri termini, grazie al SMPC, sarà possibile consentire ai Data Scientist e Data Analyst di operare sui dati senza il bisogno di esporli o spostarli dalla loro sede di storage di partenza.\citep{du2001secure}

\newpage

\hypertarget{panoramica}{%
\section{Panoramica}\label{panoramica}}

In una SMPC prendiamo in considerazione un dato numero di partecipanti che, al fine delle analisi, chiameremo \(p_1, p_2, ..., p_N\). Ad ognuno di essi verranno associati i propri dati privati che, invece, chiameremo \(d_1, d_2, ..., d_N\). L'intento del processo nasce dalla necessità dei partecipanti di calcolare il valore di una funzione pubblica con i loro dati privati: \(F(d_1, d_2, ..., d_N)\) mantenendo però i loro input segreti.

Facciamo un esempio: supponiamo di avere tre parti che chiameremo rispettivamente Alice, Bob e Charlie. A ciascuno di loro sono associati i rispettivi input \(x\), \(y\) e \(z\) che denotano i loro stipendi. Essi hanno come obbiettivo quello di scoprire quale sia, tra i tre stipendi che percepiscono, quello più alto, senza però rivelare agli altri quanto guadagna ciascuno di loro.

Questa premessa si traduce Matematicamente nel seguente calcolo: \((x,y,z) = max(x, y, z)\)

Se ci fosse una parte esterna fidata (ipotizziamo che i tre partecipanti abbiano un amico comune, lo chiameremo Tony, che deve necessariamente mantenere i segreti delle parti coinvolte), ognuno dei partecipanti potrebbe comunicare il proprio stipendio a Tony, così facendo lui potrebbe calcolare quale tra i tre è quello maggiore e, in seguito, riferire quel numero a tutti loro.

L'obiettivo di SMPC è quello di evitare la situazione in cui i partecipanti, una volta portato a termine il confronto, vengano a conoscenza di un ulteriore dato rispetto al proprio di partenza o rispetto all'output del processo. Per questo motivo il SMPC si pone come scopo quello di progettare un protocollo nel quale, scambiando messaggi solo tra di loro, Alice, Bob e Charlie possono ancora calcolare \(F(x, y, z)\) senza però rivelare il loro stipendio agli altri e senza dover dipendere da terzi. Essi infatti, durante l'esecuzione di questo protocollo, non dovrebbero venire a conoscenza di più dati di quanti ne saprebbero interagendo con un ipotetico Tony incorruttibile e perfettamente degno di fiducia.

In particolare, tutto ciò di cui le parti possono venire a conoscenza è ciò che loro stesse possono apprendere dall'output del confronto e dal loro stesso input. Così, nell'esempio precedente, se l'output è \(z\) allora Charlie impara che il suo è il valore massimo, mentre Alice e Bob imparano (se \(x\), \(y\) e \(z\) sono distinti), che il loro input non è uguale al massimo, e che il massimo è uguale a \(z\). Lo scenario di base può essere facilmente generalizzato ai casi in cui le parti hanno diversi input, diversi output e la funzione fornisce valori diversi alle diverse parti.

\newpage

Un protocollo di calcolo sicuro multipartitico deve offrire determinte garanzie di sicurezza, valide anche nei casi in cui alcune delle parti siano in collusione o cerchino di violarne le regole. Queste garanzie possono essere definite come qui in seguito:

\begin{itemize}
\tightlist
\item
  \textbf{Input Privacy}: Nessuna delle parti corrotte (o suo sottoinsieme) deve in nessun modo essere in grado di derivare alcuna informazione sui dati appartenenti alle altre parti, ad eccezione di quanto rivelato dal risultato finale dell'operazione.
\item
  \textbf{Correctness}: Nessuna delle parti corrotte (o suo sottoinsieme) deve essere in grado di indurre una parte onesta a produrre un risultato errato. Un protocollo di calcolo sicuro multipartitico, infatti, deve offrire alcune garanzie di sicurezza, persino se alcune delle parti fossero in collusione o cercassero di violarne le regole.
\end{itemize}

\hypertarget{garanzie-di-sicurezza}{%
\section{Garanzie di sicurezza}\label{garanzie-di-sicurezza}}

Per fare in modo che un protocollo di calcolo a più parti sia considerato efficace, esso deve garantire degli standard di sicurezza e, nella crittografia moderna, la sicurezza di un protocollo è strettamente legata ad una dimostrazione della sicurezza stessa del protocollo. La dimostrazione di sicurezza è da considerarsi una dimostrazione matematica in cui l'affidabilità di un protocollo è ridotta a quella della sicurezza delle sue primitive sottostanti. Tuttavia non è sempre possibile formalizzare la verifica di sicurezza del protocollo crittografico basata sulla conoscenza delle parti e sulla correttezza del protocollo stesso.

\newpage

Per i protocolli MPC, l'ambiente in cui il protocollo opera è associato alla definizione del paradigma del mondo reale e del mondo ideale. Non è possibile dire che le parti non imparino nulla, poiché devono imparare l'output dell'operazione e esso dipende direttamente dagli input. Inoltre la correttezza dell'output non è garantita poiché la correttezza dell'output dipende dagli input delle parti e si deve supporre che gli input siano corrotti.
Il paradigma del mondo reale/mondo ideale afferma due mondi che possiamo cosi definire e descrivere:

\begin{itemize}
\tightlist
\item
  Nel modello del mondo ideale esiste una parte incorruttibile fidata a cui ogni partecipante al protocollo invia il suo input. Questa parte fidata calcola la funzione da sola e rimanda l'output appropriato ad ogni parte senza rivelare ulteriori dati se non l'output del sistema.
\item
  Nel modello del mondo reale, al contrario, non esiste una parte fidata e tutto ciò che le parti possono fare è scambiare messaggi tra loro senza ricorrere ad un interlocutore esterno. Un protocollo è detto sicuro se non si può imparare di più sugli input privati di ogni parte nel mondo reale di quanto si potrebbe imparare nel mondo ideale. Nel mondo ideale nessun messaggio viene scambiato tra le parti, quindi i messaggi scambiati nel mondo reale non possono rivelare alcuna informazione segreta agli altri utenti.
\end{itemize}

Il paradigma mondo reale/mondo ideale fornisce una semplice astrazione delle complessità di MPC per consentire la costruzione di un'applicazione sotto la premessa che il protocollo MPC, nel suo nucleo, sia in realtà un'esecuzione ideale. Se l'applicazione è sicura nel caso ideale, allora è sicura anche quando viene eseguito un protocollo reale.

A differenza delle applicazioni crittografiche tradizionali, come la crittografia o la firma, si deve assumere che, in un protocollo MPC, l'avversario sia uno dei giocatori impegnati nel sistema (o che controlla le parti interne) e che dunque quella/e parti corrotte possano esse stesse colludere per violare la sicurezza del protocollo dall'interno.

\newpage

Sia \(n\) il numero di parti nel protocollo e \(t\) il numero di parti che possono essere avversarie. I protocolli e le soluzioni per il caso di \(t< n/2\) (cioè quando si assume una maggioranza onesta) sono diversi da quelli in cui non viene fatta tale assunzione, quelli cioè dove le parti avversarie all'interno del sistema siano presenti in numero maggiore rispetto alle parti oneste. Quest'ultimo scenario include l'importante caso di calcolo a due parti in cui uno dei partecipanti può essere corrotto e il caso generale in cui un numero illimitato di partecipanti è corrotto e collude per attaccare i partecipanti onesti.\citep{ben2016optimizing}

Gli avversari affrontati dai diversi protocolli possono essere classificati in base a quanto, nel loro tentativo di eludere il sistema, sono disposti a deviare dal protocollo. Ci sono essenzialmente due tipi di avversari, ognuno dei quali dà luogo a diverse forme di sicurezza (e ognuno dei quali si adatta a diversi scenari del mondo reale):

\begin{itemize}
\tightlist
\item
  \textbf{Sicurezza semi-onesta (passiva)}: In questo caso, si assume che le parti corrotte cooperino semplicemente per raccogliere informazioni dal protocollo, ma non si discostino dalle specifiche del protocollo. Questo è un tipo di avversario semplice e ingenuo, che produce quindi una sicurezza debole in situazioni reali. Tuttavia, i protocolli che raggiungono questo livello di sicurezza, impediscono la perdita involontaria di informazioni tra le parti (altrimenti collaboranti) e sono quindi utili se questa è l'unica preoccupazione. Inoltre, i protocolli nel modello semi-onesto sono abbastanza efficienti e sono spesso un primo passo importante per raggiungere livelli più alti di sicurezza.
\item
  \textbf{Sicurezza malevola (attiva)}: In questo caso, l'avversario può arbitrariamente discostarsi dall'esecuzione del protocollo nel suo tentativo di ingannare. I protocolli che raggiungono la sicurezza in questo modello forniscono una garanzia di sicurezza molto alta. Il problema sorge Nel caso in cui si presenti una maggioranza delle parti che si comportano scorrettamente. In questo specifico caso, cioè quello di maggioranza disonesta, L'unica cosa che un avversario può fare è far sì che le parti oneste interrompano il processo avendo rilevato l'imbroglio. Ne consegue dunque che, se le parti oneste ottengono l'output, allora hanno la garanzia che esso sia corretto. Anche in questi casi La loro privacy è sempre preservata.
\end{itemize}

\newpage

La sicurezza contro gli avversari attivi porta tipicamente ad una riduzione dell'efficienza che porta alla sicurezza nascosta, una forma ridotta di sicurezza attiva. La sicurezza nascosta cattura situazioni più realistiche, in cui gli avversari attivi sono disposti a barare ma solo nel caso in cui non vi è la possibilità che il loro tentativo di imbroglio possa venire scoperto. Questo accade poiché, per esempio, tale dinamica potrebbe compromettere o danneggiare la loro reputazione impedendogli così di poter collaborare in futuro con altre parti oneste.

Conseguenza di tutto ciò è che i protocolli che sono segretamente sicuri forniscono meccanismi per garantire che, se alcune delle parti non seguono le istruzioni, allora sarà notato con alta probabilità. In un certo senso gli avversari segreti sono quelli considerati attivi ma costretti ad agire passivamente a causa di preoccupazioni esterne non crittografiche (ad esempio la possibilità di compromettere il business). Questo meccanismo stabilisce un ponte tra i due modelli nella speranza di trovare protocolli che siano efficienti e abbastanza sicuri nella pratica.

Come per molti protocolli crittografici, la sicurezza di un protocollo MPC può basarsi su alcuni diversi presupposti:

\begin{itemize}
\tightlist
\item
  \textbf{Computazionale} (cioè basata su un determinato problema matematico, come la fattorizzazione) o \textbf{incondizionata}, cioè basata sull'indisponibilità fisica dei messaggi sui canali (di solito con qualche probabilità di errore che può essere resa arbitrariamente ridotta).
\item
  \textbf{Il modello potrebbe assumere diverse dinamiche}: ad esempio che i partecipanti utilizzino una rete sincronizzata dove un messaggio inviato a un ``tick'' arriva sempre al ``tick'' successivo, oppure che esista un canale di trasmissione sicuro e affidabile, o ancora che esista un canale di comunicazione sicuro tra ogni coppia di partecipanti dove un avversario non può leggere, modificare o generare messaggi nel canale, ecc.
\end{itemize}

\newpage

\hypertarget{two-party-computation}{%
\section{Two-party computation}\label{two-party-computation}}

Una particolare sotto-categoria delle SMPC che andremo di seguito ad analizzare è la Two-party computation. Questa categoria descrive uno scenario in cui due parti comunicano tra di loro per la risoluzione di un problema, senza però scambiarsi informazioni sensibili e senza ricorrere all'utilizzo di una terza parte fidata.
Lo scenario a due parti è particolarmente interessante ai fini di un'analisi in quanto non solo presenta delle diversità dal punto di vista delle applicazioni, ma anche perché a questo scenario a due si possono applicare tecniche speciali che non si applicano nel caso a più parti. Infatti, il calcolo sicuro a più parti è stato presentato per la prima volta nell'impostazione a due parti. Il lavoro originale è spesso citato come proveniente da uno dei due articoli di Yao; anche se gli articoli non contengono effettivamente quello che ora è noto come il Yao's garbled circuit protocol.

Il protocollo di base di Yao è sicuro contro gli avversari semi-onesti. E' possibile ritenere questo protcollo estremamente efficiente in termini di numero di passaggi in quanto questi sono costanti e può essere definito indipendente dalla funzione obiettivo che viene valutata. La funzione è vista come un circuito booleano, con ingressi in binario di lunghezza fissa. Un circuito booleano è un insieme di porte collegate con tre diversi tipi di fili: fili di ingresso al circuito, fili di uscita al circuito e fili intermedi. Ogni porta riceve due fili d'ingresso e ha un singolo filo d'uscita che potrebbe essere fan-out (cioè essere passato a più porte al livello successivo). La semplice valutazione del circuito viene fatta valutando ogni porta a turno e assumendo che le porte siano state ordinate topologicamente. Il gate viene rappresentato come una tabella di verità tale per cui, per ogni possibile coppia di bit (quelli provenienti dal gate dei fili di ingresso), la tabella assegna un unico bit di uscita, che è il valore del filo di uscita del gate. I risultati della valutazione sono i bit ottenuti nei fili di uscita del circuito.\citep{yao1982protocols}

\newpage

Yao ha spiegato come confondere un circuito (nascondere la sua struttura) in modo che due parti, mittente e ricevitore, possano imparare l'uscita del circuito e nient'altro. Ad un alto livello il mittente prepara il circuito confuso e lo invia al ricevitore che, ignaro, valuta il circuito imparando le codifiche corrispondenti all'uscita sua e del mittente. Una volta compiuta questa operazione si limita a rimandare le codifiche del mittente, permettendo a quest'ultimo di calcolare la sua parte di output. Il mittente invia la mappatura dalle codifiche di uscita dei ricevitori e i bit al ricevitore, permettendo a quest'ultimo di ottenere la propria uscita.
Nel capitolo successivo andremo ad analizzare più in profondità questo processo, spiegandone dettagliatamente la logica di funzionamento. \citep{Venturi2012}

\hypertarget{yao-garbled-circuit}{%
\chapter{Yao Garbled Circuit}\label{yao-garbled-circuit}}

Per meglio comprendere il funzionamento del processo lo analizzeremo utilizzano un esempio:

Si supponga che Alice e Bob siano disposti a calcolare in modo sicuro una funzione mantenendo segreti i rispettivi input e .

Per fare ciò, essi modellano prima la funzione come un circuito booleano, questo è possibile poiché esiste un circuito booleano che calcola l'uscita di per qualsiasi funzione con ingressi di dimensione fissa. Tuttavia, il modo in cui tale modellazione viene eseguita può dipendere dalla funzione e non sarà ulteriormente discusso qui. Successivamente Alice confonderà il circuito booleano e:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Per ogni filo \(w_i\) del circuito \(C\), sceglie casualmente due valori segreti \(w^{0}_{i}\), \(w^{1}_{i}\), dove \(w^{j}_{i}\) è il valore confuso del valore \(j \in \{0,1\}\) del filo \(w_i\). Si noti che \(w^{j}_{i}\) non può rivelare \(j\) di per sé, quindi Alice deve tenere traccia di \(i\) e \(j\). Questo deve essere fatto per ogni singolo filo di ingresso e di uscita di ogni porta logica del circuito, tranne che per le porte di uscita del circuito che possono essere lasciate in chiaro.
\item
  Alice dovrà costruire una tabella di verità confusa (GTT) \(T_i\) per ciascuna delle porte logiche \(G_i\) in \(C\).
\end{enumerate}

\newpage

Queste tabelle devono essere tali che dati valori confusi lungo il suo insieme di fili d'ingresso, \(T_i\) permetterà di recuperare l'uscita confusa di questo \(G_i\) e nessun'altra informazione. Questa dinamica è possibile ottenerla attraverso la crittografia dei valori di uscita. Di seguito dettaglierò ulteriormente il garbling delle porte.

\begin{figure}
\centering
\includegraphics{./media/01.png}
\caption{\label{fig:chunk-label}AND gate con etichette e tabella di verità.}
\end{figure}

In seguito, Alice può tradurre ogni bit del suo input nei suoi corrispondenti valori confusi sui fili di ingresso del circuito. Successivamente può inviare il circuito confuso a Bob con il suo input criptato.

Dopo che Bob ha ricevuto il circuito confuso, poiché tutti i fili d'ingresso sono criptati e solo Alice conosce la mappatura dei valori criptati e i bit reali, Bob ha bisogno di eseguire un Oblivious transfer con Alice per ciascuno dei suoi bit d'ingresso, in modo che Alice possa informarlo di quali valori criptati corrispondono ai suoi bit d'ingresso e sapere quali sono i suoi bit d'ingresso reali.

\begin{quote}
\textbf{Oblivius transfer}: tipo di protocollo in cui il mittente trasmette un pezzo di informazione a un ricevitore, tra tante potenziali, ma rimane ignaro al mittente quale pezzo di informazione sia stato trasmesso.
\end{quote}

Quindi significa che per ogni filo di ingresso, Bob sceglierà una tra le due stringhe casuali \(w^{0}_{i}\), \(w^{1}_{i}\) che corrispondono rispettivamente a \(0\) e \(1\), senza però conoscere il contenuto della stringa che non sceglie. Al fine di mantenere i dati in sicurezza, grazie alle proprietà del Oblivious transfer, Alice non potrà dunque conoscere l'input di Bob.

\newpage

Arrivati a questo punto del processo Bob ha a sua disposizione tutti i valori necessari per calcolare l'uscita del circuito, come discuterò in seguito. Una volta fatto ciò, può comunicare i valori di uscita ad Alice. Seguendo questo procedimento Bob è stato in grado di ottenere l'uscita di senza rivelare il suo input, né conoscere l'input di Alice, questo significa che Alice e Bob hanno simulato con successo una terza parte fidata e hanno eseguito un SMPC sicuro in cui è garantita la privacy di entrambi gli utenti partecipanti al sistema.

\hypertarget{garbling-logical-gates}{%
\section{Garbling Logical Gates}\label{garbling-logical-gates}}

La nozione di garbling delle porte logiche e della loro tabella di verità risulta essere un punto cruciale in questa dinamica. Senza perdita di generalità, considererò solo le porte logiche con due fili di ingresso e un filo di uscita. Come spiegato precedentemente, per una data porta \(G \in C\) e i suoi fili d'ingresso \(W_0, W_1\) e il suo filo di uscita \(W\), Alice doveva scegliere sei diverse stringhe casuali, \(w^{0}_{0}, w^{1}_{0}, w^{0}_{1}, w^{1}_{1}, w^0, w^1\) che ha assegnato a ciascun valore dei fili in una mappatura uno a uno, dove \(w^{j}_{i}\) rappresenta la stringa casuale assegnata al valore \(j\) del filo \(W_i\).

Quindi, per confondere la tabella di verità di \(G\) in modo da non rivelare alcuna informazione dati due valori di ingresso \(w_0\), \(w_1\) eccetto il suo valore di uscita \(w\) e nemmeno il tipo di porta logica, Alice può criptare i valori di uscita \(w_0\), \(w_1\) usando i valori di ingresso confusi come chiavi, adottando un dato schema di crittografia simmetrica \(\mathbb{E}\).

Utilizzeremo la notazione \(\mathbb{E}_{k_0,k_2}(x) = \mathbb{E}_{k_0}(\mathbb{E}_{k_1}(x))\) per indicare la cifratura doppia con due chiavi date \(k_0, k_1\). Come esempio, criptiamo la tabella di verità della porta AND della figura:

\[\begin{array}{c|c|c||c}
W_0 & W_1 & W & \text{Garbled value} \\ \hline
        w_0^0 & w_1^0 & w^0 & \mathbb{E}_{w_0^0,w_1^0}(w^0) \\
        w_0^0 & w_1^1 & w^0 & \mathbb{E}_{w_0^0,w_1^1}(w^0) \\
        w_0^1 & w_1^0 & w^0 & \mathbb{E}_{w_0^1,w_1^0}(w^0)\\
        w_0^1 & w_1^1 & w^1 & \mathbb{E}_{w_0^1,w_1^1}(w^1) \\
\end{array}\]

La GTT \(T\) del gate \(G\) è semplicemente l'insieme \(\left\lbrace\mathbb{E}_{w_0^j,w_1^k}(w^{G(j,k)}) \mid j,k \in \left\lbrace0,1\right\rbrace \right\rbrace\) dei valori confusi, dove \(G(j,k)\) corrisponde all'uscita della porta \(G\) sotto ingressi \((j,k)\).

\newpage

\hypertarget{valutazione-del-garbled-circuit}{%
\section{Valutazione del Garbled Circuit}\label{valutazione-del-garbled-circuit}}

Una volta che Bob ha ricevuto il circuito confuso \(C\) da Alice e ha ottenuto i valori confusi del suo input attraverso diversi Oblivious transfer, egli può valutare il circuito.

Come premessa è però importante capire che un circuito confuso differisce da un normale circuito booleano per alcuni fattori:
In un circuito booleano, infatti, semantica e sintassi sono fondamentalmente le stesse. Questo significa che vengono assegnati ad ogni filo due possibili valori semantici, cioè Vero o Falso, e che ,quest'ultimi ,sintatticamente si denotano come un segnale con valori 1 o 0 rispettivamente.

I segnali sopra citati sono considerabili pubblici e, questi stessi segnali sono associati ad ogni filo e chiunque può dedurre dal segnale quale sia il suo valore semantico. Questa condizione cambia però in un circuito confuso.

Nelle dinamiche di un circuito confuso, infatti, i valori semantici riferiti ad ogni segnale, eccetto quelli di uscita del circuito, sono mantenuti segreti e i segnali variano da un filo all'altro.

In questo modo, per valutare il circuito, per ogni porta\(G_i\) del circuito, Bob può provare a decifrare i valori nella tabella di verità associata \(T_i\) usando i valori di ingresso della porta come chiavi. Una delle voci in \(T_i\) sarà poi decifrata nell'uscita del gate.

questo punto del processo, sembrerebbe necessario avere un oracolo come unica strada praticabile per la conferma del successo della decrittazione delle voci di \(T_i\); tuttavia è possibile ricorrere ad un ``trucco'' che descriverò più dettagliatamente qui di seguito.

Questo particolare espediente viene chiamato permute-and-point e viene usato per la prima volta \citep{INPROCEEDINGS} successivamente spiegato più nel dettaglio nella tesi di Phillip Rogoway\citep{prog}.

Il permute-and-point permette di decidere quale voce della GTT deve essere decrittata dati gli input confusi, permettendo di eseguire calcoli più veloci e impedendo comunque al valutatore di dedurre qualcosa dall'ordine delle voci della tabella di verità. \citep{kolesnikov2008improved}

\newpage

\hypertarget{permute-and-point}{%
\section{Permute-and-point}\label{permute-and-point}}

Il meccanismo di Permute-and-point funziona nel seguente modo: per ogni filo di ingresso e uscita \(w_i\), Alice concatena un bit casuale \(a \in \{0,1\}\) alla fine del suo valore confuso \(w^{0}_i\) e concatena il suo valore inverso \(b = \overline{a} = 1 - a\) alla fine di \(w^{1}_{i}\). Così facendo è dunque possibile associare ciascuna delle 4 permutazioni di 2 bit ad una delle entrate della GTT, senza però avere alcuna correlazione tra i bit e i valori della tabella della verità non confusa. In questo modo Alice può semplicemente ordinare la GTT secondo l'ordinamento naturale e darla a Bob che sarà quindi in grado di dedurre, senza bisogno di ulteriori informazioni, quale voce deve decifrare su un dato input. Per ottenere una rappresentazione ancora più chiara di questo ``trucco'', quei bit possono essere rappresentati come una coppia di colori, come è possibile osservare nella figura 2.2, in cui si notano le modalità con cui la tabella di verità viene modificata in modo da tenere conto di questo metodo.

\begin{figure}
\centering
\includegraphics{./media/02.png}
\caption{AND garbled con permute on point}
\end{figure}

Queste modifiche permettono a Bob di decifrare semplicemente la voce il cui indice corrisponde ai colori associati ai suoi fili di ingresso e quindi di ottenere il valore del filo di uscita e il suo colore, permettendogli di valutare ulteriormente il circuito. \citep{4568207}

\newpage

\hypertarget{esempio-di-valutazione}{%
\section{Esempio di Valutazione}\label{esempio-di-valutazione}}

\begin{figure}
\centering
\includegraphics{./media/03.png}
\caption{AND garbled con permute on point}
\end{figure}

Andiamo ora ad analizzare come si potrebbe valutare il circuito confuso rappresentato nella Figura 2.3 usando il metodo permute-and-point che abbiamo discusso precedentemente. Assumiamo che i valori semantici di ingresso di \((W_1,W_2,W_3,W_4)\) siano \((0,0,1,0)\), il che significa che l'input confuso effettivo è \(({\color{green}\bullet}{}w_1^0,{\color{red}\bullet}{}w_2^0,{\color{red}\bullet}{}w_3^1,{\color{green}\bullet}{}w_4^0)\) dove gli \(w^i_j\) sono i valori casuali che Alice ha scelto quando ha confuso il circuito, come visto sopra. Assumiamo anche che Alice abbia già fornito il suo input confuso, diciamo \((W_1,W_3)\), e che Bob abbia già ottenuto il suo input confuso \((W_2,W_4)\) da Alice attraverso due applicazioni di Oblivious transfer come descritto nel paragrafo riguardante.

Bob comincerà quindi a valutare prima la porta AND utilizzando l'ingresso \(({\color{green}\bullet}{}w_1^0,{\color{red}\bullet}{}w_2^0)\), dato che ha i colori \(\color{green}\bullet\color{red}\bullet\) cercherà di decifrare la terza voce della GGT della porta AND, che funziona e quindi gli fornirà il valore confuso \({\color{green}\bullet}{}w_5^0\).

Potrà poi continuare la sua valutazione con la seconda porta, che è la porta OR. Guardando il suo ingresso \(({\color{red}\bullet}{}w_3^1,{\color{green}\bullet}{}w_4^0)\) e proverà a decifrare la voce corrispondente a \(\color{red}\bullet\color{green}\bullet\) con le chiavi \((w_3^1,w_4^0)\), essa si decifra nel valore confuso \({\color{green}\bullet}{}w_6^1\).

Potrà ora decifrare la porta XOR finale usando l'ingresso calcolato \(({\color{green}\bullet}{}w_5^0,{\color{green}\bullet}{}w_6^1)\), decifrando così la voce \(\color{green}\bullet\color{green}\bullet\) che gli fornisce il risultato finale: \(1\).

Bob non è a conoscenza di quale sia stato effettivamente l'input di Alice, ne conosce solo l'output finale ``1'' e le stringhe generate casualmente \(w_1^0,w_2^0,w_3^1,w_4^0,w_5^0,w_6^1\). Egli può ancora, per esempio, dedurre dal circuito che i valori semantici di \(w_5^0\) e \(w_6^1\) sono opposti, tuttavia questo sistema non gli permette di invertire il circuito confuso fino ai valori di ingresso di Alice.

Ci sono alcuni circuiti in cui non è assicurata la privacy, come per esempio un circuito che calcola la somma degli ingressi. Tuttavia, in questo caso di esempio Bob, conoscendo i suoi valori semantici di ingresso, può semplicemente limitare gli ingressi di Alice a un sottoinsieme dei possibili ingressi, ma non può determinare in modo univoco i reali valori di ingresso di Alice. \citep{hemenway2014achieving}

\hypertarget{la-sintesi-dei-circuiti}{%
\chapter{La sintesi dei circuiti}\label{la-sintesi-dei-circuiti}}

Nel capitolo precedente abbiamo discusso dell'importanza della presenza di un circuito logico all'interno del protocollo creato da Yao. A livello di funzionalità La scelta di un circuito efficiente è da considerarsi un fattore importantissimo in quanto rende la computazione e i tempi di calcolo delle operazioni non elevati. Ciò che effettivamente rende efficace la scelta è trovare il giusto bilanciamento tra numero di input che le 2 parti coinvolte devono immettere nel circuito e, nel caso di un dominio multi valore, scegliere un dominio non troppo elevato poiché quest'ultimo andrebbe ad immettere, per ogni valore di input, troppi valori che di conseguenza porterebbero ad aumentare i costi totali del circuito. \citep{brayton1999multi}

La scelta di questi circuiti viene facilitata dall'utilizzo di strumenti chiamati sintetizzatori, questi tool sono stati creati appositamente per andare a ridurre quanto possibile le dimensioni dei circuiti dati loro in ingresso. All'interno di questo lavoro di analisi sono stati utilizzati due tool differenti: \textbf{MVSIS} e \textbf{ABC}. Entrambi sono stati sviluppati nel tempo dall'università di Berkley. Sia \textbf{MVSIS} che \textbf{ABC} contengono diversi metodi di sintesi capaci di andare ad eliminare i nodi e le ridondanze superflue all'interno dei circuiti e in grado di sintetizzare il circuito andandone a cambiare radicalmente la struttura interna dei nodi.

Nonostante l'uguale utilizzo per il quale questi due diversi tool sono stati sviluppati, vi sono comunque alcune differenze tra loro che andremo ad analizzare qui di seguito.

\newpage

\hypertarget{mvsis}{%
\section{MVSIS}\label{mvsis}}

\textbf{MVSIS} è il primo tool di sintesi dei circuiti di cui parleremo. Grazie alla sua implementazione esso è in grado di manipolare i circuiti con una logica detta ``logica multi valore''. Per la sua creazione è stato preso come modello \textbf{SIS}, un tool sviluppato e specifico per la logica binaria, cercando di mantenerne simile la logica di funzionamento.

\hypertarget{design-specification}{%
\subsection{Design specification}\label{design-specification}}

Un circuito multi valore (MV circuit) può essere dato come valore di input a MVSIS tramite l'apposito comando (read\_blifmv) e, oltre ai circuiti multi valore, è possibile anche dare come imput circuiti binari. Internamente, la rappresentazione del progetto è una rete di nodi MV dove ogni nodo rappresenta una funzione MV con una singola uscita a più valori. È importante però specificare una fondamentale distinzione con alcuni altri metodi multi valore, cioè che ogni variabile del nodo può avere un dominio diverso. L'intervallo per la variabile \(y_k\) è rappresentato dall'insieme \$P\_k=\{0,1,\ldots{},p\_k -1 \}. La funzione il cui esito dà UN SET dei mintermi (Una sola uscita con 0 o 1) per i quali \(f_k = i\) (la funzione al nodo \(k\) è uguale al valore \(i\) ) è chiamata \emph{i-set} della funzione \(f_k\) e viene memorizzata in forma SOP (Somma di prodotti). Nel caso di logica a 2 valori, l'insieme 0 corrisponde all'off-set e l'insieme 1 all'on set. Una variabile MV yk è associata all'uscita del nodo k. Un margine congiunge \(k\) a \(j\) se uno qualsiasi degli i-set di \(j\) dipende esplicitamente da \(y_k\). La rete ha un insieme di ingressi primari (che possono essere tutti a più valori) e un insieme di nodi di ingressi primari.

\newpage

\hypertarget{semplificazione-dei-nodi}{%
\subsection{Semplificazione dei nodi}\label{semplificazione-dei-nodi}}

L'i-set (uno per ogni valore di output) di un nodo multi valore può essere semplificato con 2 comandi:

\begin{itemize}
\tightlist
\item
  SIMPLIFY
\item
  FULLSIMP
\end{itemize}

FULLSIMP, tra le 2 opzioni, è quella che garantisce una semplificazione più efficace poichè Utilizza il CODC (Compatible Observability Don't Cares) e l' MV-image computation. Ogni i-set del nodo è in seguito semplificato dal metodo di sintesi ESPRESSO-MV utilizzando i valori che siamo stati in grado di ricavare ricorrendo alle due tecniche precedenti. \citep{mvsis}

\hypertarget{kernel-e-cube-extraction}{%
\subsection{Kernel e Cube Extraction}\label{kernel-e-cube-extraction}}

Oltre all'utilizzo dei sintetizzatori vi è però un altro importante step che è possibile applicare per operare un' ottimizzazione del circuito: questo ulteriore passaggio consiste nell'applicare metodi algebrici al fine di estrarre nuovi nodi che hanno divisori comuni per altri nodi. Nel tempo sono state sviluppate nuove tecniche algebriche dedicate alla logica MV che ci permettono di trattare uniformemente le variabili binarie e multi-valore. Tra le loro funzioni queste tecniche algebriche includono svariate possibilità, tra cui: metodi per trovare sottoespressioni comuni, divisione semi-algebrica, decomposizione di una rete multi-valore e fattorizzazione di una forma SOP. Per fare maggiore chiarezza di seguito verranno elencati i comandi più rilevanti, seguiti da alcune brevi descrizioni delle loro capacità.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{FX}: questo comando individua divisori comuni all'interno della rete e crea nuovi nodi all'interno di essa, nei quali vengono raccolti tutti i nodi coinvolti nel divisore comune.
\item
  \textbf{Decomp}: questo comando esegue una completa fattorizzazione multivaloriale degli i-sets di ogni nodo e, in seguito, suddivide i nodi secondo queste fattorizzazioni. Dopo questo procedimento viene utilizzato il comando \emph{resub}, che ricorre alla divisione algebrica multi valore per eliminare i fattori duplicati all'interno della rete.
\end{enumerate}

\newpage

\hypertarget{altri-comandi-per-la-manipolazione-dei-nodi}{%
\subsection{Altri comandi per la manipolazione dei nodi}\label{altri-comandi-per-la-manipolazione-dei-nodi}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Collapsing}: converte l'intera rete multilivello in modo che le forme SOP per ogni uscita siano in termini di soli ingressi primari. Così il numero di nodi nella rete sarà esattamente il numero di uscite primarie.
\item
  \textbf{Merging}: Acquisisce tutti i nodi della rete e forza un'unione di questi, così facendo genera un singolo nodo multi-valore costruendo un i-set per ogni combinazione di valori creata. Nel caso in cui da questo processo vengano generati i-set uguali, essi vengono uniti in un singolo nodo.
\item
  \textbf{Encoding}: è considerabile come l'inverso del merging di funzioni binarie, esso infatti cerca di trovare una buona codifica binaria per ogni variabile multi-valore nella rete, compresi gli ingressi e le uscite primarie. Alla fine di questo procedimento ogni segnale è codificato come un segnale binario. È possibile quindi, grazie al comando encoding, scrivere un file binario a partire da un multi valore. Questo processo di traslazione può essere così spiegato in due fasi:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Inizia dagli ingressi e per ogni nodo, determina se uno dei suoi fanin può essere usato per codificare parzialmente il nodo.
  \item
    nizia dalle uscite e, in ordine topologico inverso, lavora a ritroso fino agli ingressi primari. Ad ogni nodo, le sue uscite sono codificate utilizzando le informazioni su come sono utilizzati i suoi fanout.
  \end{enumerate}
\item
  \textbf{Pair decoding}: Ha la stessa funzione del merging, ma, a differenza del precedente, questo comando utilizza un altro metodo per scegliere quali nodi unire.
\item
  \textbf{Bi-decomposition}: Produce dei nodi multi-valore intermedi. Esso acquisisce una rete MV appiattita, o parzialmente appiattita, e ne genera una nuova composta da porte MAX e MIN multi-valutate a due ingressi e da iterali multi-valutati. In questo processo, per la creazione dei nuovi nodi, vengono sfruttate sia l'incompletezza della specifica iniziale che le flessibilità generate nel processo di composizione. \citep{chai2003mvsis} \citep{yang1991logic}
\end{enumerate}

\newpage

\hypertarget{abc}{%
\section{ABC}\label{abc}}

ABC è un sistema software in sviluppo che ha come obbiettivi la sintesi e la verifica di circuiti logici sequenziali binari che appaiono in progetti hardware. Il meccanismo di ABC si basa sulla combinazione di un'ottimizzazione logica scalabile basata su And-Inverter Graphs (AIGs), una mappatura tecnologica basata su DAG per tabelle di look-up, celle standard e algoritmi innovativi per la sintesi e la verifica sequenziale.

Si può dire che questo programma sia nato dalle esperienze assimilate dall'uso di SIS, VIS e MVSIS. Lo sviluppo di ABC è stato portato avanti in quanto questi sistemi precedentemente citati non erano in grado di fornire un ambiente di programmazione flessibile per implementare le recenti innovazioni. Per quanto riguarda l'ambiente SIS, esso risulta essere obsoleto e piuttosto inefficiente nella gestione di grandi circuiti. VIS, invece, essendo stato progettato come strumento di verifica formale per specifiche multi-valore, non fornisce abbastanza flessibilità per la sintesi binaria. Diverso è invece il discorso per quanto riguarda MVSIS che, nonostante il suo ampio utilizzo, presenta alcune problematiche:

\begin{itemize}
\tightlist
\item
  Le strutture dati e gli algoritmi di base di MVSIS possono essere resi considerevolmente più semplici e facili da utilizzare assumendo come punto di partenza le reti binarie.
\item
  Un posto centrale nel nuovo sistema dovrebbe essere dato a una nuova struttura dati, le AIG (reti logiche multilivello composte da AND e inverter a due ingressi), che promettono miglioramenti nella qualità e nel tempo di esecuzione della sintesi e della verifica.
\end{itemize}

La comprensione di queste problematiche ha spinto a ri-sviluppare i pacchetti di base di MVSIS creando un nuovo ambiente di programmazione chiamato ABC. Come suggerisce il nome, l'obiettivo primario di questo sistema software è quello di mantenere strutture di dati semplici e flessibili in modo da poter essere impiegate da una vasta gamma di applicazioni.

L'obiettivo del progetto ABC è quello di fornire un'implementazione pubblica degli algoritmi di sintesi combinatoria e sequenziale allo stato dell'arte e, allo stesso tempo, creare un ambiente open-source, in cui tali applicazioni possano essere sviluppate e confrontate. La versione attuale di ABC può ottimizzare, mappare e realizzare progetti industriali a livello di gate con 100K porte e 10K elementi sequenziali cont tempi di calcolo non superiori al minuto prendendo in considerazione un computer moderno. \citep{mishchenko2007abc}

\newpage

\hypertarget{sintesi-combinatoria}{%
\subsection{Sintesi combinatoria}\label{sintesi-combinatoria}}

Per comprendere a pieno l'innovazione di ABC ci basta eseguire una comparazione con MVSIS. Infatti, i metodi di logica combinatoria utilizzati da ABC all'interno dei suoi script (resyn e resyn2) sono tipicamente 10-100 volte più veloci se messi a confronto con gli script utilizzati all'interno di SIS o MVSIS.

In ABC, i confini dei nodi sono inizialmente distrutti dall'hashing strutturale (comando strash), che trasforma una rete logica in un AIG. I confini possono essere ricreati su richiesta utilizzando il comando renode, che può essere considerato come un inverso del comando SIS eliminate. Nel flusso di sintesi presentato sopra la logica viene trasformata a livello di AIG senza creare nodi.

\begin{itemize}
\tightlist
\item
  \textbf{Balance}: prende come ingresso un AIG e lo bilancia in modo tale che la struttura risulti equilibrata per il calcolo.
\item
  \textbf{Cleanup}: Mette in atto la rimozione dei nodi logici che non sono a ventaglio in PO e latches.
\item
  \textbf{Collapse}: Collassa l'intero circuito ad una rete ad un solo livello. Le funzioni dei nodi sono rappresentate utilizzando le BDD.
\item
  \textbf{Dsd}: Applica al circuito la decomposizione disjoint-support utilizzando l'algoritmo di Bertacco/Damiani \citep{ICCAD97}.
\item
  \textbf{fx}: Rileva la logica di condivisione estraendo i divisori a due cubi e i divisori a due lettere a un cubo sfruttando l'algoritmo di Rajski/Vasudevamurthi \citep{TCAD92}.
\item
  \textbf{Multi}: Espande l'AIG a due ingressi generando una rete di porte AND a più ingressi.
\item
  \textbf{refactor}: Esegue il collasso iterativo e il refactoring dei coni logici nell'AIG con lo scopo di ridurre sia il numero di nodi AIG che il numero di livelli logici.
\end{itemize}

\newpage

\begin{itemize}
\tightlist
\item
  \textbf{renode}: Assume che l'input sia un AIG. Crea i confini dei nodi in quest'ultimo e collassa la logica intermedia per formare nodi più grandi.
\item
  \textbf{rewrite}: Assume che l'input sia un AIG. Crea i legami tra i nodi in quest'ultimo e collassa la logica intermedia allo scopo di formare nodi più grandi.
\item
  \textbf{rr}: Esegue la rimozione della ridondanza per le AIG.
\item
  \textbf{strash}: Trasforma la rete data in imput al programma in un AIG tramite un livello di hashing strutturale. L'AIG risultante è una rete logica composta da due fattori: porte AND a due ingressi e invertitori rappresentati come attributi complementari sui bordi. L'hashing strutturale è una trasformazione puramente combinatoria che, in quanto tale, non modifica in alcun modo il numero e le posizioni delle porte.
\item
  \textbf{sweep}: Grazie al suo funzionamento Sweep esegue i seguenti compiti: rimuove i nodi dangling (nodi senza fanout), collassa i buffer e gli inverter nei loro fanout, propaga le costanti, e rimuove i fanin duplicati. Sweep non può però essere applicato a un AIG perché quest'ultimo è strutturalmente hashed e quindi non ha buffer, invertitori e nodi costanti non propagati. Per rimuovere i nodi dandling nella rete logica è necessario dunque utilizzare cleanup. tramite questi comandi sweep è in gradi di ridisegnare completamente il circuito a livello strutturale.
\end{itemize}

\newpage

\hypertarget{sintesi-sequenziale}{%
\subsection{Sintesi sequenziale}\label{sintesi-sequenziale}}

La sintesi sequenziale è un processo che, ove presenti, trasforma la rete corrente modificandone la logica insieme agli elementi di memorizzazione (latches o flip-flops). La rete risultante dalla sintesi sequenziale può avere una codifica di stato e uno spazio di stato diversi rispetto alla rete originale, ma le due reti sono sequenzialmente equivalenti; nello specifico, (partendo dagli stati iniziali, per le stesse sequenze di vettori d'ingresso vengono generate sequenze identiche di vettori d'uscita). \citep{manual2006quick}

\begin{itemize}
\tightlist
\item
  \textbf{Cycle}: Simula la rete sequenziale con un input casuale per poi aggiornare il suo stato attuale..
\item
  \textbf{init}: Ripristina gli stati iniziali di tutte le porte della rete corrente.
\item
  \textbf{lcorr}: Attua una implementazione suddivisa di registro-corrispondenza usando l'induzione semplice, per poi rilevare e fondere registri che siano sequenzialmente equivalenti.
\item
  \textbf{retime}: Implementa diversi tipi di retiming, tra questi citiamo i seguenti:

  \begin{itemize}
  \tightlist
  \item
    most forward;
  \item
    most backward;
  \item
    minimum-register;
  \item
    minimum-delay euristico;
  \item
    delay-optimal retiming \citep{ICCD_1997}
  \end{itemize}

  Quando il circuito è trasformato dall'AIG in una rete logica, le porte sono condivise in modo ottimale attraverso gli archi di fanout. Il calcolo degli stati iniziali dopo il retiming è ridotto ad un problema SAT che viene risolto ricorrendo a MiniSat.
\item
  \textbf{scleanup}: Esegue la pulizia sequenziale, cioè rimuove i nodi e le latches che non sono a fanout.
\item
  \textbf{ssw}: Implementa i segnali corrispondenti applicando l'induzione K-step. In seguito Rileva e fonde i nodi sequenzialmente equivalenti.
\item
  \textbf{undc}: Converte i registri con gli stati iniziali don't care in registri con uno stato iniziale costante -0. In particolare è possibile utilizzare questo comando prima di eseguire qualsiasi verifica sequenziale.
\item
  \textbf{xsim}: Esegue la simulazione con \(X\) valore della rete sequenziale corrente.
\end{itemize}

\hypertarget{analisi}{%
\chapter{Analisi}\label{analisi}}

Il protocollo di Yao prevede, durante i suoi scambi, che le due parti coinvolte concordino anche sulla trasmissione di un circuito a cui entrambi gli attori debbano inserire dei valori di input. Uno degli scopi della nostra tesi consiste nel testare l'efficacia dell'utilizzo di un multi valore rispetto all'utilizzo ``classico'' di un circuito booleano, concentrandoci specificatamente sull'importante valore costituito dal fattore di costo computazionale delle operazioni che vengono svolte.

Per avviare la nostra analisi siamo partiti quindi selezionando un set di circuiti binari con caratteristiche diverse, tra cui differente numero di ingressi, uscite e livelli. Partendo da questa base ci siamo successivamente concentrati sulla ricerca di una metodologia di conversione dei circuiti atta a traslarli da un `classico' dominio booleano ad uno multi valore, dove quindi i valori non sono più rappresentati da 0 e 1 ma da un set più ampio di valori. Tutto ciò sempre mantenendo le funzionalità del circuito. Una volta ottenuta una controparte per ogni circuito si è proceduto con un confronto dei circuiti al fine di riuscire ad individuare quali di questi set fossero più efficaci.

\newpage

\hypertarget{la-logica-multi-valore}{%
\section{La logica multi-valore}\label{la-logica-multi-valore}}

La logica multi-valore è una generalizzazione della classica logica booleana. Una delle ragioni per la quale è stata presa in considerazione è che essa può portare ad una comprensione più profonda di problemi specifici. La logica multi valore può avere numerosi vantaggi teorici rispetto a quelle booleana:

\begin{itemize}
\tightlist
\item
  Memory design: Memorizzare informazioni a blocchi di 2bit invece che uno raddoppia la densità delle informazioni che si possono racchiudere nello stesso spazio.
\item
  Utilizzo per rappresentazione di funzioni booleane con più output;
\item
  Design di PLA con input decoder;
\item
  Ottimizzazione di macchine a stato finite;
\item
  Testing e verifica.
\end{itemize}

Le potenzialità pratiche di questi vantaggi dipendono pesantemente dalla disponibilità della realizzazione di questi circuiti che devono comunque rimanere compatibili con gli standard tecnologici odierni. \citep{gao2002optimization}

\newpage

\hypertarget{le-funzioni-multi-valore}{%
\subsection{Le funzioni multi-valore}\label{le-funzioni-multi-valore}}

Una funzione multi-valore è una funzione discreta che ha, sia come input che come output, delle variabili che assumono più di 2 valori. Solitamente le funzioni multi-valore sono definite come: \(f: P_1 \times P_2 \times ... P_n \rightarrow Q\) dove le variabili \(x_i\) della funzione prendono valore dal gruppo \(P_i = \{ 0,1,2,...,p_i-1 \}, p_i > 1 , i \in \{ 1,2,...,n\}\) e la funzione prende valori dal set \(Q = \{0,1,2,...,q\}, q>1\)

\hypertarget{rappresentazione-di-funzioni-multi-valore}{%
\subsection{Rappresentazione di funzioni multi-valore}\label{rappresentazione-di-funzioni-multi-valore}}

Il modo più semplice per rappresentare un funzione con \(m\) valori e \(n\) variabili consiste nel creare una tabella di verità con \(m^n\) righe, ognuna delle quali specifica il valore della funzione corrispondente alla combinazione delle variabili in ingresso. Una tabella di verità può essere ridisegnata come un rettangolo n-dimensionale con m-valore in una mappa di Karneaugh. Il problema di queste due rappresentazioni consiste nella difficoltà di raffigurazione in caso di tabelle complesse. Nei prossimi capitoli mostrerò metodi di rappresentazione più efficaci per la logica multi valore.

\hypertarget{positional-cube-notation}{%
\subsubsection{Positional cube notation}\label{positional-cube-notation}}

Utilizzata nella logica booleana, questa tecnica di visualizzazione può essere applicata anche per funzioni con input multi valore e output booleano. A differenza di un letterale binario, \(x\) o \(x'\), viene rappresentato da un campo a 2 bit, una funzione letterale multi valore \(m\) viene rappresenta con un campo a \(m\) bit. Il valore \(i \in M\) corrisponde al bit \(i\) dell campo. Un letterale \(x^S\) presenta il valore 1 in tutte le posizioni \(i \in S\). Per esempio:

\[\begin{tabular}{ c|c c c} 
 \hline
 x1/x2 & 0 & 1 & 2 \\ 
 0 & 1 & 0 & 0 \\ 
 1 & 1 & 1 & 1 \\
 2 & 0 & 1 & 1 \\
 \hline
\end{tabular}\]

\newpage

Applicando la Positional Cube Notation esso diventa:

\[\begin{array}{ccc}
110 & - & 100 \\
101 & - & 010 \\
011 & - & 001 
\end{array}\]

Per quanto riguarda il caso booleano la condizione don't care di un valore in una riga corrisponde al fatto che quell'elemento può assumere valori 0 o 1. Per una funzione multi valore, invece, una condizione don't care può essere rappresentata nel seguente modo:

\begin{itemize}
\tightlist
\item
  Si spezza la funzione \(f: M^n \rightarrow M\), rispettandone tutti i valori \(i \in M\), generando \(m\) funzioni multi valore, input e output multi valore utilizzando la seguente logica \(f^i: M^n \rightarrow \{0,1\}\)
\item
  Infine si rappresenta ognuna delle funzioni spezzate nella notazione. \citep{Dubrova2002}
\end{itemize}

\hypertarget{multiple-valued-network}{%
\subsubsection{Multiple Valued Network}\label{multiple-valued-network}}

Una Multiple Valued network è un grafo multi-livello simile a quello booleano con la differenza che ogni nodo rappresenta una funzione multi valore. Per sistemi con alto livello di astrazione l'utilizzo di questi grafi può rendere il design della progettazione più intuitivo. Prendiamo, per esempio, il controller di un semaforo, esso può prendere valore \emph{rosso}, \emph{giallo} o \emph{verde} piuttosto che considerare l'encoding in modo binario. Questo tipo di progettazione è possibile solamente semplificando il sistema fino al punto in cui non è possibile renderlo ancora più ottimale nella manipolazione del dominio dei valori. Il lato negativo di questa tecnica è che la rappresentazione di un sistema non si presenta in forma canonica, poichè una funzione può assumere più rappresentazioni. Questo lato negativo rende il testing più difficoltoso.

\newpage

\hypertarget{mdds}{%
\subsubsection{MDDS}\label{mdds}}

I Multiple Valued Decision Diagrams sono una generalizzazione degli alberi binari di decisione (BDDs). Le funzioni sono rappresentate creando un diagramma aciclico con nodi non terminali \(v\) etichettati da una variabile di indice \(index(i), i \in \{1,2,...,n\}\). Ogni vertice \(v\) ha \(m\) uscite dirette verso i nodi figli, chiamati \(child_j(v), j \in M\). Ogni vertice terminale \(v\) ha come attributo un valore \(value(v)\) in \(M\).

\includegraphics[width=0.7\textwidth,height=\textheight]{./media/04.png}

\newpage

\hypertarget{studio-del-circuito-binario}{%
\section{Studio del circuito binario}\label{studio-del-circuito-binario}}

Analizzando i vari circuiti per testare la tesi è stato necessario, ai fini dell'analisi, sviluppare una tecnica di conversione dei circuiti binari di partenza. La caratteristica di una naturale rappresentazione di un circuito consiste nella sua divisione in nodi, ognuno dei quali viene rappresentato da una tabella di verità i cui input e output vanno a correlarsi tra loro tramite dei collegamenti. Soffermandosi più attentamente sulle tabelle di verità è stato possibile notare come, andando ad applicare un raggruppamento di \(n\) bit per ogni riga della tabella, sarebbe possibile riuscire a rappresentare un valore di dominio più grande di quello binario del circuito in analisi. Di conseguenza, così facendo, è possibile attuare una riduzione del numero di input richiesti dal gate.

\[\begin{matrix}
    \underbrace{10} & \underbrace{11} & \underbrace{00} \\
    \downarrow & \downarrow & \downarrow  &mod_3 \\
    2 & 3 & 0
\end{matrix}\]

Con questo approccio è possibile non snaturare quella che è la logica della tabella originale poiché, sapendo qual è il nuovo dominio applicato, vi è la possibilità di invertire il processo di conversione, ritornando quindi al circuito originale.

È necessario però considerare i vincoli presentati da questo approccio di conversione dei circuiti booleani. Queste limitazioni risiedono nel fatto che, al momento, la conversione può essere attuata solo e soltanto con un numero pari di input e che il numero di output sia un divisore del numero di bit utilizzati per il raggruppamento.

\newpage

Una volta definito il metodo di conversione e preso atto dei vincoli di questo tipo di approccio, abbiamo proseguito con la scelta del nuovo dominio da applicare ai circuiti, questo con l'obiettivo di trovare il giusto compromesso per ottenere i seguenti risultati:

\begin{itemize}
\item
  Una riduzione degli input che facesse diminuire il costo del circuito di ingresso rispetto al circuito di partenza.
\item
  Trovare un dominio multi valore che risulti efficace nella riduzione dei costi. avere un dominio superiore a quello booleano ma troppo elevato significherebbe che, per ogni input, ogni parte dovrebbe inserire tanti valori di input quanti quelli del dominio richiesto e, se si sceglie un dominio troppo grande, nonostante la riduzione degli input ci si troverebbe comunque con un costo totale del circuito elevato. Si è deciso quindi di sperimentare 2 approcci alla scelta di questo valore, uno statico e uno dinamico.

  \begin{itemize}
  \tightlist
  \item
    \textbf{Statico}: per ognuno dei circuiti andremo ad applicare lo stesso valore di dominio, il valore scelto è 3, in seguito procederemo quindi a raggruppare ogni 2 valori per riga della tabella di verità;
  \item
    \textbf{Dinamico}:ogni circuito verrà analizzato andando a trovare il numero di input e output, successivamente procedendo con il calcolo del valore di M.C.D. e:

    \begin{itemize}
    \tightlist
    \item
      Se il valore trovato consente alla tabella di verità convertita di avere almeno 2 valori di input, in quel caso si utilizza quel valore per raggruppare i bit delle righe, altrimenti il valore viene dimezzato.
    \item
      Se il valore risultante è un numero che creerebbe un dominio troppo grande, in quel caso viene utilizzato il dominio 3, come nel caso statico.
    \end{itemize}
  \end{itemize}
\end{itemize}

Una volta definite tutte le logiche di conversione è stato necessario affrontare una seconda problematica: identificare un formato di file che rispettasse determinati requisiti, tra questi citiamo:

\begin{itemize}
\tightlist
\item
  un formato in grado di rappresentare i circuiti
\item
  un formato che rispetti le esigenze per poter applicare tutte le elaborazioni sopra descritte
\item
  un formato che possa essere scelto come standard di rappresentazione in modo tale che i risultati ottenuti possano essere utilizzati dai software di sintesi che andremo ad utilizzare successivamente durante l'elaborazione della sperimentazione.
\end{itemize}

\newpage

Si è presentata dunque la necessità di una rappresentazione che avesse la possibilità di rappresentare i circuiti con output multipli sulla stessa linea all'interno della tabella di verità.

Tra i vari formati a disposizione, dopo averne analizzate le caratteristiche, la scelta è ricaduta sul formato \texttt{PLA}, già ampiamente utilizzato per la rappresentazione di circuiti.
Per comprendere meglio questa scelta è necessario però andare a sviscerare le caratteristiche e la struttura del formato selezionato.

\hypertarget{analisi-della-struttura-pla}{%
\subsection{Analisi della struttura PLA}\label{analisi-della-struttura-pla}}

La struttura di un file PLA può essere così descritta:

\begin{verbatim}
.i 4
.o 2
.ilb x1 x2 y1 y2
.ob f1 f2
0--0 00    
0001 01
0-11 --
1-11 01
0101 10
10-- 01
11-- 00
.end
\end{verbatim}

Questo \texttt{PLA} preso come esempio rappresenta un circuito composto da una sola tabella di verità, la sintassi va a descrivere gli elementi nel seguente modo:

\begin{itemize}
\tightlist
\item
  \texttt{.i}: numero di valori di input;
\item
  \texttt{.o}: numero di valori di output;
\item
  \texttt{.ilb}: nomi e ordine delle variabili di input;
\item
  \texttt{.ob}: nomi e ordine delle variabili di output.
\end{itemize}

\newpage

Il resto del file riportato rappresenta la tabella di verità con i possibili valori che si ottengono combinando i valori di input\_file per ottenere gli output. Il circuito sopra descritto presenta 4 variabili di input e 2 valori di output. Come possiamo osservare all'interno della tabella di verità non tutti i valori sono booleani, è infatti presente anche il valore ``-'', esso prende il nome di don't care e, all'interno del file, può assumere due significati diversi:

\begin{itemize}
\tightlist
\item
  Quando - è presente negli output di una riga significa che l'output per quella determinata riga non genera un valore interessante ai fini dell'analisi;
\item
  Quando - è presente negli input significa che, in quella posizione, la variabile a cui fa riferimento può assumere un qualsiasi valore non andando ad influire sul valore di output che si andrà ad ottenere.
\end{itemize}

La presenza di questo nuovo valore, non presente nel caso dei circuiti booleani classici, ci presenta la necessità di analizzare e capire il metodo con cui andare a gestire questi don't care all'interno del circuito.

\hypertarget{la-gestione-dei-dont-care-durante-la-conversione}{%
\subsection{La gestione dei don't care durante la conversione}\label{la-gestione-dei-dont-care-durante-la-conversione}}

I dont't care sono una caratteristica dei file PLA che deve essere gestita in modo funzionale ai cambi di dominio che andremo ad eseguire all'interno delle tabelle di verità dei nostri circuiti. Questa gestione è di primaria importanza in quanto, se affrontata nel modo sbagliato, modificherebbe la logica dell'intero circuito, rendendo di conseguenza la conversione errata. Per fare più chiarezza riguardo il trattamento che va applicato a questa caratteristica dei PLA, è presentato l'esempio di un circuito semplice che ha come valore di dominio di conversione il valore 3. Il circuito avrà la seguente struttura:

\begin{verbatim}
.i 4
.o 2
.ilb x1 x2 y1 y2
.ob f1 f2
0--0 00    
0001 01
0-11 --
1-11 01
0101 10
10-- 01
11-- 00
.end
\end{verbatim}

\newpage

Una volta stabilito il nostro nuovo dominio di conversione sappiamo quanti bit dobbiamo raggruppare per rappresentare il nostro nuovo dominio. Nel nostro caso, essendo il domino 3, il numero di bit per rappresentare il valore più grande di questo dominio, abbiamo bisogno di un raggruppamento a 2 bit. Procediamo quindi a scandire riga per riga il circuito, raggruppando i bit a blocchi di due sia per tutti i valori di input che per quelli di output.

\begin{verbatim}
0- -0 00    
00 01 01
0- 11 --
1- 11 01
01 01 10
10 -- 01
11 -- 00
\end{verbatim}

Una volta creati questi cluster di bit ci rendiamo conto di come i dont't care, in alcuni casi, ci rendano impossibile la conversione al nuovo dominio. Per fare in modo che questo problema venga risolto, sarà necessario andare a sviluppare questi valori di don't care in `normali' valori booleani.

\newpage

Non è però sempre necessario andare a sviluppare i don't care, per questo motivo si differenziano due possibili casistiche di intervento applicabili a questi casi:
- Quando il numero di `-' è uguale al numero di bit del raggruppamento multi valore. Quando si presenta questa situazione non c'è la necessità di sviluppare i valori, sarà infatti sufficiente inserire al posto della coppia di bit un nuovo - rappresentante il don't care.
\[ \begin{array}{ccc}
        10 & -- & 01 \\ & \downarrow & \\ 2 & - & 1 
    \end{array}\]
- Quando nel gruppo di bit raggruppati il numero di - è minore del numero di bit richiesti. Quando si presenta questa circostanza è necessario procedere con l'espansione del dont't care a valori di verità, questo in modo tale da poter affrontare correttamente la conversione nel nuovo dominio.
\[ \begin{array}{cccc}
            1- & 11 & 01\\
            & \downarrow &\\
            10 & 11 & 01\\
            11 & 11 & 01\\
            & \downarrow &\\
            2 & 3 & 1\\
            3 & 3 & 1
        \end{array}\]

\newpage

Analizzando e applicando queste due differenti casistiche ci è dunque possibile sviluppare tutto il circuito binario e ottenere una conversione esatta. Il circuito convertito sarà quindi.

\begin{verbatim}
00 0
02 0
10 0
12 0
01 1
03 -
13 -
23 1
11 2
2- 1
3- 0
\end{verbatim}

Con questa nuova struttura è in fine possibile procedere all'analisi dei circuiti, proseguendo in seguito con l'attività di sintesi logica.

\hypertarget{implementazione-della-conversione}{%
\section{Implementazione della conversione}\label{implementazione-della-conversione}}

La conversione dei circuiti in analisi viene implementata utilizzando il linguaggio di programmazione Python nella versione 3.8. Questo implemento avviene senza l'ausilio di nessun package esterno, vengono infatti utilizzate solamente librerie che sono già comprese nel linguaggio in questione.

Questa dinamica fa si che il sistema, una volta installato il linguaggio di programmazione, se non già presente all'interno del SO, risulti essere ``ready to use''.

\newpage

\hypertarget{analisi-del-circuito}{%
\subsection{Analisi del circuito}\label{analisi-del-circuito}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ read_pla(path_file):}
\NormalTok{  inp }\OperatorTok{=} \VariableTok{None}
\NormalTok{  out }\OperatorTok{=} \VariableTok{None}
\NormalTok{  inp_array }\OperatorTok{=}\NormalTok{ []}
\NormalTok{  out_array }\OperatorTok{=}\NormalTok{ []}
\NormalTok{  truth_table }\OperatorTok{=}\NormalTok{ []}
  \ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(path_file, }\StringTok{'r'}\NormalTok{) }\ImportTok{as}\NormalTok{ input_file:}
    \ControlFlowTok{for}\NormalTok{ line }\KeywordTok{in}\NormalTok{ input_file.readlines():}
      \ControlFlowTok{if} \StringTok{'.i'} \KeywordTok{in}\NormalTok{ line }\KeywordTok{and}\NormalTok{ line[}\DecValTok{2}\NormalTok{] }\OperatorTok{==} \StringTok{' '}\NormalTok{:}
\NormalTok{        inp }\OperatorTok{=}\NormalTok{ line.split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{]}
      \ControlFlowTok{elif} \StringTok{'.o'} \KeywordTok{in}\NormalTok{ line }\KeywordTok{and}\NormalTok{ line[}\DecValTok{2}\NormalTok{] }\OperatorTok{==} \StringTok{' '}\NormalTok{:}
\NormalTok{        out }\OperatorTok{=}\NormalTok{ line.split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{]}
      \ControlFlowTok{elif} \StringTok{'.ilb'} \KeywordTok{in}\NormalTok{ line:}
\NormalTok{        inp_array }\OperatorTok{=}\NormalTok{ line.strip().split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{:]}
      \ControlFlowTok{elif} \StringTok{'.ob'} \KeywordTok{in}\NormalTok{ line:}
\NormalTok{        out_array }\OperatorTok{=}\NormalTok{ line.strip().split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{:]}
      \ControlFlowTok{elif} \StringTok{'.end'} \KeywordTok{in}\NormalTok{ line:}
        \ControlFlowTok{continue}
      \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        line }\OperatorTok{=}\NormalTok{ \{}
          \StringTok{'inp'}\NormalTok{:  line.strip().split(}\StringTok{' '}\NormalTok{)[}\DecValTok{0}\NormalTok{],}
          \StringTok{'out'}\NormalTok{:  line.strip().split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{]}
\NormalTok{        \}}
\NormalTok{        truth_table.append(line)}
  \ControlFlowTok{return}\NormalTok{ inp, out, inp_array, out_array, truth_table}
\end{Highlighting}
\end{Shaded}

All'interno del processo sopra rappresentato la funzione prende in input un circuito binario in formato PLA. Riga per riga, procede ad un'analisi delle informazioni in base al prefisso all'interno di ogni riga del file. Questo prefisso va a differenziare le informazioni del circuito e scandendo il file recupera le seguenti informazioni:

\begin{itemize}
\tightlist
\item
  Tabella delle verità
\item
  Numero di input
\item
  Numero di output
\item
  Array contenente il nome delle variabili di input;
\item
  Array contenente il nome delle variabili di output;
\end{itemize}

Queste informazioni saranno necessarie successivamente per poter convertire il circuito e poterne calcolare costi effettivi.

\newpage

\hypertarget{espansione-dei-dont-care}{%
\subsection{Espansione dei don't care}\label{espansione-dei-dont-care}}

Una volta ottenute tutte le informazioni disponibili dal circuito dato, succesivamente è necessario andare ad identificare all'interno delle tabelle di verità quali sono i don't care a cui bisogna espandere i valori e quelli che si possono ignorare. Questo passaggio nello specifico è stato la parte più impegnativa riguardante le funzionalità del programma.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n_dont_care }\OperatorTok{=} \StringTok{''}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(dv):}
\NormalTok{    n_dont_care }\OperatorTok{+=} \StringTok{'-'}
\end{Highlighting}
\end{Shaded}

Con questo ciclo vado a creare un array di \texttt{-} consecutivi che rispecchiano i cluster di don't care da ignorare nel durante l'analisi delle tabelle di verità. Avrò quindi un array di \emph{n} \texttt{-} tanti quanti il numero di bit per rappresentare i numeri del nuovo dominio.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{len_truth_table }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(truth_table)}
\NormalTok{i }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{while}\NormalTok{ i }\OperatorTok{<}\NormalTok{ len_truth_table:}
  \ControlFlowTok{if} \StringTok{'-'} \KeywordTok{in}\NormalTok{ truth_table[i][}\StringTok{'inp'}\NormalTok{]:}
\NormalTok{    truth_table[i][}\StringTok{'inp'}\NormalTok{] }\OperatorTok{=} \StringTok{''}\NormalTok{.join(truth_table[i[}\StringTok{'inp'}\NormalTok{])}
\NormalTok{    truth_table[i][}\StringTok{'inp'}\NormalTok{] }\OperatorTok{=}\NormalTok{ [truth_table[i][}\StringTok{'inp'}\NormalTok{[a:a}\OperatorTok{+}\NormalTok{dv]}
        \ControlFlowTok{for}\NormalTok{ a }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, le(truth_table[i][}\StringTok{'inp'}\NormalTok{], dv)]}
    \ControlFlowTok{for}\NormalTok{ a }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(truth_table[i][}\StringTok{'inp'}\NormalTok{])):}
        \ControlFlowTok{if}\NormalTok{ truth_table[i][}\StringTok{'inp'}\NormalTok{][a] }\OperatorTok{==}\NormalTok{ n_dont_care:}
\NormalTok{            truth_table[i][}\StringTok{'inp'}\NormalTok{][a] }\OperatorTok{=} \StringTok{'k'}\OperatorTok{*}\NormalTok{le(n_dont_care)}
\NormalTok{    truth_table[i][}\StringTok{'inp'}\NormalTok{] }\OperatorTok{=} \StringTok{''}\NormalTok{.join(truth_table[i[}\StringTok{'inp'}\NormalTok{])}
\NormalTok{    new_lines }\OperatorTok{=}\NormalTok{ resolve_dont_care(truth_table[i],}\StringTok{'inp'}\NormalTok{)}
\NormalTok{    truth_table }\OperatorTok{=}\NormalTok{ truth_table[:i] }\OperatorTok{+}\NormalTok{ new_lines }\OperatorTok{+}\NormalTok{truth_table[i}\OperatorTok{+}\DecValTok{1}\NormalTok{:]}
\NormalTok{    len_truth_table }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(truth_table)}
\NormalTok{  i }\OperatorTok{+=} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\newpage

Tramite questo ciclo \emph{while} l'intero circuito viene scandito e:

\begin{itemize}
\tightlist
\item
  I valori di input vengono divisi in cluster di \emph{n} bit per rappresentare i nuovi valori del dominio;
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{truth_table[i][}\StringTok{'inp'}\NormalTok{] }\OperatorTok{=}\NormalTok{ [}
\NormalTok{   truth_table[i][}\StringTok{'inp'}\NormalTok{[a:a}\OperatorTok{+}\NormalTok{dv]}
   \ControlFlowTok{for}\NormalTok{ a }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{, le(truth_table[i][}\StringTok{'inp'}\NormalTok{], dv)]}
\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Se all'interno dei cluster sono presenti solamente don't care il valore \texttt{-} viene sostituito con il valore \emph{k} per differenziarli dai valori dont't care che successivamente verranno espansi
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ truth_table[i][}\StringTok{'inp'}\NormalTok{][a] }\OperatorTok{==}\NormalTok{ n_dont_care:}
\NormalTok{  truth_table[i][}\StringTok{'inp'}\NormalTok{][a] }\OperatorTok{=} \StringTok{'k'}\OperatorTok{*}\NormalTok{le(n_dont_care)}
\end{Highlighting}
\end{Shaded}

Ora la tabelle è finalmente pronta per l'espansione dei don't care tramite l'appostia funzione sviluppata

Si è utilizzato un ciclo \emph{while} in questa funzione nonostante in Python sia meno efficiente a causa della natura della sua implementazione; questo perchè la lunghezza della tabella della verità aumenta dinamicamente con l'andare dell'espansione dei don't care individuati.

\hypertarget{resolve-dont-care}{%
\subsubsection{Resolve don't care}\label{resolve-dont-care}}

La funzione inizia andando ad individuare quanti don't care sono presenti nella linea

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ resolve_dont_care(line, in_out):}
\NormalTok{  n_dc }\OperatorTok{=} \BuiltInTok{pow}\NormalTok{(}\DecValTok{2}\NormalTok{, line[in_out].count(}\StringTok{'-'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\newpage

Successivamente viene iniziato un ciclo che scandisce ogni elemento della linea della tabella di verità, viene creato un array binario della di tante righe quante saranno dopo l'espansione dei don't care.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ h }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(line[in_out].count(}\StringTok{'-'}\NormalTok{)):}
\NormalTok{  val_array }\OperatorTok{=}\NormalTok{ create_0_1_array(n_dc, }\BuiltInTok{pow}\NormalTok{(}\DecValTok{2}\NormalTok{, h))}
\end{Highlighting}
\end{Shaded}

Successivamente vengono differenziate 2 casistiche:

\begin{itemize}
\tightlist
\item
  Prima iterazione
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ h }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(n_dc):}
\NormalTok{    it }\OperatorTok{=} \DecValTok{0}
\NormalTok{    new_line }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(input_entry)}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{-1}\NormalTok{, }\DecValTok{-1}\NormalTok{):}
      \ControlFlowTok{if}\NormalTok{ input_entry[j] }\OperatorTok{==} \StringTok{'-'} \KeywordTok{and}\NormalTok{ it }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{        new_line.append(val_array[(}\BuiltInTok{len}\NormalTok{(val_array)}\OperatorTok{-}\DecValTok{1}\NormalTok{) }\OperatorTok{-}\NormalTok{ i])}
\NormalTok{        it }\OperatorTok{+=} \DecValTok{1}
      \ControlFlowTok{else}\NormalTok{:}
\NormalTok{        new_line.append(line[in_out][j])}
\NormalTok{    new_array.append(new_line[::}\OperatorTok{-}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Tutte le successive
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{else}\NormalTok{:}
\NormalTok{  it }\OperatorTok{=} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ c, l }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(new_array):}
    \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(l)}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{-1}\NormalTok{, }\DecValTok{-1}\NormalTok{):}
      \ControlFlowTok{if}\NormalTok{ l[j] }\OperatorTok{==} \StringTok{'-'} \KeywordTok{and}\NormalTok{ it }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{        l[j] }\OperatorTok{=}\NormalTok{ val_array[(}\BuiltInTok{len}\NormalTok{(val_array)}\OperatorTok{-}\DecValTok{1}\NormalTok{) }\OperatorTok{-}\NormalTok{ c]}
\NormalTok{        it }\OperatorTok{+=} \DecValTok{1}
\NormalTok{    it }\OperatorTok{=} \DecValTok{0}
\end{Highlighting}
\end{Shaded}

Ogni riga viene scandita a partire dal fondo per iniziare a convertire i don't care corrispondenti ai valori meno significativi. Sfruttando l'array binario creato sopra andiamo a sostituire il simbolo `-' con con il valore booleano corrispondente e quindi a creare una nuova linea di un array che conterrà tutti i valori ottenuti dall'espansione.

\newpage

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ in_out }\OperatorTok{==} \StringTok{'inp'}\NormalTok{:}
  \ControlFlowTok{return}\NormalTok{ [\{}\StringTok{'inp'}\NormalTok{:  l, }\StringTok{'out'}\NormalTok{:  line[}\StringTok{'out'}\NormalTok{]\} }\ControlFlowTok{for}\NormalTok{ l }\KeywordTok{in}\NormalTok{ new_array]}
\ControlFlowTok{else}\NormalTok{:}
  \ControlFlowTok{return}\NormalTok{ [\{}\StringTok{'inp'}\NormalTok{:  line[}\StringTok{'inp'}\NormalTok{], }\StringTok{'out'}\NormalTok{:  l\} }\ControlFlowTok{for}\NormalTok{ l }\KeywordTok{in}\NormalTok{ new_array]}
\end{Highlighting}
\end{Shaded}

Come possiamo notare dal \texttt{return} della funzione, questa operazione di espansione è possibile sia sugli input che su gli output. Come detto nel capitolo precedente anche l'espansione dei valori di don't care degli output è importante per non perdere l'integrità del circuito.

L'oggetto restituito dalla funzione è un array contenente un vocabolario con la stessa struttura che è stata usata durante l'estrazione dei dati dal file \texttt{PLA}, questo array sostituirà la riga contenente i don't care espansi.

\hypertarget{create_0_1_array}{%
\subsubsection{create\_0\_1\_array}\label{create_0_1_array}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ create_0_1_array(le, pad):}
\NormalTok{  count_1 }\OperatorTok{=}\NormalTok{ pad}
\NormalTok{  count_0 }\OperatorTok{=}\NormalTok{ pad}
  \ControlFlowTok{return}\NormalTok{ [}\BuiltInTok{str}\NormalTok{(}\DecValTok{1}\NormalTok{) }\ControlFlowTok{if}\NormalTok{ i }\OperatorTok{%}\NormalTok{ (count_1 }\OperatorTok{+}\NormalTok{ count_0) }\OperatorTok{<}\NormalTok{ count_1 }
    \ControlFlowTok{else} \BuiltInTok{str}\NormalTok{(}\DecValTok{0}\NormalTok{) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(le)]}
\end{Highlighting}
\end{Shaded}

Questa funzione restituisce una tabella di verità data una linea con all'interno un numero di don't care che necessitano di espansione.

Questa tabella creata verrà inserita al posto della linea con i don't care del circuito in modo tale da avere la tabella corretta per la conversione.

Una volta terminato l'intero ciclo tutti i dont't care saranno risolti e la tabella sarà pronta per la conversione nel nuovo valore di dominio.

\newpage

\hypertarget{la-conversione-in-multi-valore}{%
\section{La conversione in multi valore}\label{la-conversione-in-multi-valore}}

Le funzioni analizzate e osservate nelle sezioni precedenti restituiscono sempre come valore di output una matrice corrispondente alla tabella della verità sviluppata. Questa tabella verrà utilizzata dalla funzione di conversione seguendo lo schema spiegato all'inizio del capitolo.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ create_mv_truth_table(truth_array, dv):}
\NormalTok{  conv_truth }\OperatorTok{=}\NormalTok{ []}
  \ControlFlowTok{for}\NormalTok{ line }\KeywordTok{in}\NormalTok{ truth_array:}
\NormalTok{    line[}\StringTok{'inp'}\NormalTok{] }\OperatorTok{=} \StringTok{''}\NormalTok{.join(line[}\StringTok{'inp'}\NormalTok{])}
\NormalTok{    line[}\StringTok{'inp'}\NormalTok{] }\OperatorTok{=}\NormalTok{ [line[}\StringTok{'inp'}\NormalTok{][i }\OperatorTok{*}\NormalTok{ dv:(i }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{*}\NormalTok{ dv]}
      \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{((}\BuiltInTok{len}\NormalTok{(line[}\StringTok{'inp'}\NormalTok{]) }\OperatorTok{+}\NormalTok{ dv }\OperatorTok{-} \DecValTok{1}\NormalTok{) }\OperatorTok{//}\NormalTok{ dv)]}
    \ControlFlowTok{if} \StringTok{'-'} \KeywordTok{not} \KeywordTok{in}\NormalTok{ line[}\StringTok{'out'}\NormalTok{]:}
\NormalTok{      line[}\StringTok{'out'}\NormalTok{] }\OperatorTok{=} \StringTok{''}\NormalTok{.join(line[}\StringTok{'out'}\NormalTok{])}
\NormalTok{      line[}\StringTok{'out'}\NormalTok{] }\OperatorTok{=}\NormalTok{ [line[}\StringTok{'out'}\NormalTok{][i }\OperatorTok{*}\NormalTok{ dv:(i }\OperatorTok{+} \DecValTok{1}\NormalTok{) }\OperatorTok{*}\NormalTok{ dv]}
        \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{((}\BuiltInTok{len}\NormalTok{(line[}\StringTok{'out'}\NormalTok{]) }\OperatorTok{+}\NormalTok{ dv }\OperatorTok{-} \DecValTok{1}\NormalTok{) }\OperatorTok{//}\NormalTok{ dv)]}
\NormalTok{      l_supp_inp }\OperatorTok{=}\NormalTok{ []}
\NormalTok{      l_supp_out }\OperatorTok{=}\NormalTok{ []}
      \ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ line[}\StringTok{'inp'}\NormalTok{]:}
        \ControlFlowTok{if} \StringTok{'-'} \KeywordTok{not} \KeywordTok{in}\NormalTok{ val:}
\NormalTok{          l_supp_inp.append(}\BuiltInTok{int}\NormalTok{(val, }\DecValTok{2}\NormalTok{))}
        \ControlFlowTok{else}\NormalTok{:}
\NormalTok{          l_supp_inp.append(}\StringTok{'-'}\NormalTok{)}
      \ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ line[}\StringTok{'out'}\NormalTok{]:}
\NormalTok{        l_supp_out.append(}\BuiltInTok{int}\NormalTok{(val, }\DecValTok{2}\NormalTok{))}
\NormalTok{      conv_truth.append(\{}
        \StringTok{'inp'}\NormalTok{:  l_supp_inp,}
        \StringTok{'out'}\NormalTok{:  l_supp_out}
\NormalTok{      \})}
  \ControlFlowTok{return}\NormalTok{ conv_truth}
\end{Highlighting}
\end{Shaded}

La funzione prende in ingresso la matrice espansa creata precedentemente e il numero di bit da utilizzare per rappresentare il massimo numero del nuovo dominio multi valore.

\newpage

Inizialmente la funzione `spezza' la stringa dei valori di input in gruppi di tanti elementi quanti sono i bit per rappresentare il massimo numero, successivamente viene controllato se il gruppo è composto da:

\begin{itemize}
\tightlist
\item
  dont't care: in questo caso si procede sostituendoli con un singolo simbolo `-'
\item
  numeri binari: in quest'altro caso si procede con la conversione tramite il metodo int(), per applicare questa conversione sono però necessari due parametri differenti:

  \begin{itemize}
  \tightlist
  \item
    un numero o una stringa di numeri da convertire
  \item
    la base a cui si vuole fare la conversione
  \end{itemize}
\end{itemize}

Una volta scandita tutta la tabella di verità abbiamo finalmente ricavato un circuito convertito. L'utlimo processo da mettere in atto consiste nell'andare a creare un file compatibile per la sintesi dei circuiti.

\hypertarget{la-creazione-del-file-blfmv}{%
\section{La creazione del file blfmv}\label{la-creazione-del-file-blfmv}}

Per i circuiti multi valore non viene adottato il formato PLA in quanto quest'ultimo viene utilizzato solamente per i circuiti binari. Per sopperire a questa limitazione data dal formato PLA si farà uso di un altro formato standard appositamente creato per la logica multi valore: il formato blfmv.

Questo formato deriva dal formato blif, ampiamente utilizzato per la logica binaria.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mv_input }\OperatorTok{=}\NormalTok{ [i }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{list}\NormalTok{(string.ascii_lowercase)[}
\NormalTok{    :}\BuiltInTok{len}\NormalTok{(mv_table[}\DecValTok{0}\NormalTok{][}\StringTok{'inp'}\NormalTok{])]}
\NormalTok{  ]}
\NormalTok{mv_output }\OperatorTok{=}\NormalTok{ [}\StringTok{'o}\SpecialCharTok{\{\}}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(i) }\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\BuiltInTok{len}\NormalTok{(mv_table[}\DecValTok{0}\NormalTok{][}\StringTok{'out'}\NormalTok{]))]}
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv/}\SpecialCharTok{\{\}}\StringTok{.mv'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir, nomefile), }\StringTok{'w'}\NormalTok{) }\ImportTok{as}\NormalTok{ blif:}
\NormalTok{  blif.write(}\StringTok{'.model }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir, nomefile))}
\NormalTok{  blif.write(}\StringTok{'.inputs }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
      \StringTok{' '}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{, mv_input))))}
\NormalTok{  blif.write(}\StringTok{'.outputs }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
      \StringTok{' '}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{, mv_output))))}
\NormalTok{  blif.write(}\StringTok{'.mv }\SpecialCharTok{\{\}}\StringTok{ }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
      \StringTok{', '}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{, mv_input)), mv))}
\NormalTok{  blif.write(}\StringTok{'.mv }\SpecialCharTok{\{\}}\StringTok{ }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
      \StringTok{', '}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{, mv_output)), mv))}
  \ControlFlowTok{for}\NormalTok{ count, out }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(mv_output):}
\NormalTok{      blif.write(}\StringTok{'.table }\SpecialCharTok{\{\}}\StringTok{ }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
        \StringTok{' '}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{,mv_input)), out)}
\NormalTok{      )}
    \ControlFlowTok{for}\NormalTok{ line }\KeywordTok{in}\NormalTok{ mv_table:}
\NormalTok{      blif.write(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{ }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
        \StringTok{' '}\NormalTok{.join(}\BuiltInTok{map}\NormalTok{(}\BuiltInTok{str}\NormalTok{, line[}\StringTok{'inp'}\NormalTok{])), line[}\StringTok{'out'}\NormalTok{][count]))}
\NormalTok{  blif.write(}\StringTok{'.end}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Questa funzione crea un file .mv relativo al circuito creato. Scegliamo questa tipo di file e sintassi poiché nelle fasi successive andremo ad utilizzare dei software che accettano questa sintassi per valutare e sintetizzare i circuiti.

\newpage

\hypertarget{la-sintesi}{%
\section{La sintesi}\label{la-sintesi}}

Una volta ottenuti sia il circuito booleano che quello multi valore procederemo con la sintesi dei circuiti. Quest'ultima si pone come obiettivo la riduzione e l'ottimizzazione della struttura dei circuiti stessi, andando a diminuire il numero di ingressi e di tabelle della verità in modo tale da avere dei costi totali minori.

I programmi utilizzati per la sintesi logica sono stati entrambi sviluppati dall'università di Berkley e attualmente sono disponibili con licenza open source.

Per la sintesi durante l'analisi sperimentale sono state utilizzate due alternative:

\begin{itemize}
\tightlist
\item
  MVSIS
\item
  ABC
\end{itemize}

\hypertarget{mvsis-1}{%
\subsection{MVSIS}\label{mvsis-1}}

E' il primo programma utilizzato, al suo interno troviamo diversi metodi di sintesi da poter applicare, i quali sfruttano tecniche differenti. La particolarità di questo tool consiste nel fatto che il programma è in grado di accettare come input sia circuiti binari che multi valore. Il lato negativo dell'utilizzo di questo programma, d'altra parte, è che l'ultima versione di questo software risale al 2005 e quindi non è più mantenuto.

\hypertarget{abc-1}{%
\subsection{ABC}\label{abc-1}}

ABC, come la sua alternativa descritta sopra, mette a disposizione delle tecniche di sintesi che presentano il vantaggio di avere degli script pronti che uniscono più metodi, in questo modo è possibile avere la certezza di non commettere errori o di utilizzare una concatenazione di metodi inefficace.

ABC è un'evoluzione di MVSIS e del più vecchio SIS. Esso viene tuttora mantenuto ma, a differenza di MVSIS, se gli viene dato in ingresso un valore di input, esso viene successivamente convertito in binario e solo in seguito è possibile utilizzare i metodi di sintesi.

Una caratteristica molto utile di questi programmi sta nel fatto che essi accettano come parametri di ingresso degli script contenenti tutte le istruzioni da eseguire. Proseguendo con lo sviluppo della tesi sarà possibile dimostrare come tutto il processo di analisi viene automatizzato sfruttando questa caratteristica.

\newpage

\hypertarget{la-sintesi-tramite-i-software}{%
\subsection{La sintesi tramite i software}\label{la-sintesi-tramite-i-software}}

La letteratura mette già a disposizione delle sequenze di metodi di sintesi e pulizia dei circuiti efficace ed efficiente, questi comandi si possono chiamare semplicemente dando in input ai due programmi un file contenente un alias per questa sequenza di istruzioni.

\begin{verbatim}
source abc_alias.abc
read_blif_mv ./prova/blfmv/amd.mv
strash
compress2
cl
resyn2
cl
write_blif_mv ./prova/blfmv/synth/amd.mv
\end{verbatim}

Il programma, in questo caso ABC, non fa altro che prendere come input uno dei circuiti creati precedentemente e, applicando i metodi di sintesi, crea un ulteriore file contenente il circuito sintetizzato. In questo modo è successivamente possibile fare degli ulteriori confronti, una volta sintetizzati tutti i circuiti.

\hypertarget{il-calcolo-dei-costi-del-circuito}{%
\section{Il calcolo dei costi del circuito}\label{il-calcolo-dei-costi-del-circuito}}

Il costo del circuito viene calcolato sulla base di due fattori fondamentali:
- Quanti input devono inviare entrambe le parti
- Quanti valori devono inviare per ciascun valore di input in base al dominio

Per calcolare questo tipo di informazioni si devono effettuare delle ulteriori operazioni di lettura sui file precedentemente creati, il tutto analizzando due differenti caratteristiche:

\begin{itemize}
\tightlist
\item
  Gli ingressi di ogni tabella di verità del circuito (andando a controllare quali dei valori di input devono essere inseriti da una delle parti e quali sono ingressi di valori di output delle altre tabelle.)
\item
  Il dominio dei valori di input che devono inserire le parti.
\end{itemize}

\newpage

\hypertarget{blfmv-vs-pla}{%
\subsection{blfmv vs pla}\label{blfmv-vs-pla}}

Per poter eseguire il confronto sopra citato si è preferito utilizzare file che avessero la stessa sintassi di rappresentazione del circuito, sia nel caso multi valore che in quello booleano.

Il formato \emph{pla} attualmente non dispone di un'alternativa per i file multi valore, ma non è ancora supportata dai tool che abbiamo in utilizzo. Per questo motivo si è deciso di utilizzare il formato \emph{blif} per rappresentare i circuiti binari. \emph{Blif} è l'alternativa binaria a \emph{blfmv}, la sintassi è la stessa con la differenza che non viene specificato il dominio dei valori di input in quanto sempre booleano.

La differenza con \emph{pla}, invece, sta nel fatto che gli output non possono essere in numero maggiore di 1 per tabella: nella rappresentazione avrò quindi, per ogni nodo del circuito, tante tabelle quanti sono gli output di quel nodo. Questa tipologia di rappresentazione è utilizzata anche nei file \emph{blfmv}, quindi sarà possibile una comparazione 1:1 tra il circuito binario e quello multi valore.

Per effettuare questa conversione vengono in aiuto i tool ABC e MVSIS, poiché entrambi contengono metodi di conversione automatica da \emph{pla} a \emph{blif}. Questa operazione viene effettuata tramite uno script contenente le istruzioni da eseguire e dato come parametro di ingresso al programma. \citep{kukimoto1996blif}

\begin{verbatim}
read_pla ./prova/pla/alu2.pla
write_blif ./prova/blif/alu2.blif
\end{verbatim}

A questo punto dell'analisi abbiamo a disposizione tutti i file per poter fare effettuare il confronto dei costi.

\newpage

\hypertarget{implementazione}{%
\subsection{Implementazione}\label{implementazione}}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/}\SpecialCharTok{\{\}}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir, circuito)) }\ImportTok{as}\NormalTok{ circ:}
  \BuiltInTok{input} \OperatorTok{=} \VariableTok{None}
\NormalTok{  output }\OperatorTok{=} \VariableTok{None}
\NormalTok{  mv }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\NormalTok{  table_array }\OperatorTok{=}\NormalTok{ []}
  \ControlFlowTok{for}\NormalTok{ line }\KeywordTok{in}\NormalTok{ circ.readlines():}
    \ControlFlowTok{if} \StringTok{'.inputs'} \KeywordTok{in}\NormalTok{ line.strip():}
      \BuiltInTok{input} \OperatorTok{=}\NormalTok{ line.strip().split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{:]}
    \ControlFlowTok{if} \StringTok{'.outputs'} \KeywordTok{in}\NormalTok{ line.strip():}
\NormalTok{      output }\OperatorTok{=}\NormalTok{ line.strip().split(}\StringTok{' '}\NormalTok{)[}\DecValTok{1}\NormalTok{:]}
    \ControlFlowTok{if} \StringTok{'.mv'} \KeywordTok{in}\NormalTok{ line.strip():}
      \ControlFlowTok{if}\NormalTok{ mv }\OperatorTok{<} \BuiltInTok{int}\NormalTok{(line.strip().split(}\StringTok{' '}\NormalTok{)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]):}
\NormalTok{        mv }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(line.strip().split(}\StringTok{' '}\NormalTok{)[}\OperatorTok{-}\DecValTok{1}\NormalTok{])}
    \ControlFlowTok{if} \StringTok{'.table'} \KeywordTok{in}\NormalTok{ line.strip():}
\NormalTok{      l }\OperatorTok{=}\NormalTok{ line.strip().split(}\StringTok{' '}\NormalTok{)}
\NormalTok{      table_array.append(}
\NormalTok{        \{}
          \StringTok{'input'}\NormalTok{:    l[}\DecValTok{1}\NormalTok{:}\BuiltInTok{len}\NormalTok{(l)}\OperatorTok{-}\DecValTok{1}\NormalTok{],}
          \StringTok{'output'}\NormalTok{:   l[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{        \}}
\NormalTok{      )}
    \ControlFlowTok{if} \StringTok{'.names'} \KeywordTok{in}\NormalTok{ line.strip():}
\NormalTok{      l }\OperatorTok{=}\NormalTok{ line.strip().split(}\StringTok{' '}\NormalTok{)}
\NormalTok{      table_array.append(}
\NormalTok{        \{}
          \StringTok{'input'}\NormalTok{:    l[}\DecValTok{1}\NormalTok{:}\BuiltInTok{len}\NormalTok{(l)}\OperatorTok{-}\DecValTok{1}\NormalTok{],}
          \StringTok{'output'}\NormalTok{:   l[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{        \}}
\NormalTok{      )}
  \CommentTok{# i blif non hanno .mv, quindi gli do il valore di dominio}
  \ControlFlowTok{if}\NormalTok{ mv }\OperatorTok{==} \DecValTok{0}\NormalTok{:}
\NormalTok{    mv }\OperatorTok{=} \DecValTok{2}
  \ControlFlowTok{return}\NormalTok{ \{}
    \StringTok{'dominio'}\NormalTok{:   mv,}
    \StringTok{'input'}\NormalTok{:    }\BuiltInTok{input}\NormalTok{,}
    \StringTok{'output'}\NormalTok{:   output,}
    \StringTok{'tabelle'}\NormalTok{:  table_array}
\NormalTok{  \}}
\end{Highlighting}
\end{Shaded}

\newpage

Questa funzione, dato un circuito sia binario che mutli-valore, prende tutte le informazioni ad essa necessarie per poter effettuare il calcolo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{costo }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ t }\KeywordTok{in}\NormalTok{ circuito[}\StringTok{'tabelle'}\NormalTok{]:}
\NormalTok{  intersection }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(}\BuiltInTok{set}\NormalTok{(circuito[}\StringTok{'input'}\NormalTok{]).intersection(t[}\StringTok{'input'}\NormalTok{]))}
\NormalTok{  costo }\OperatorTok{=}\NormalTok{ costo }\OperatorTok{+} \BuiltInTok{pow}\NormalTok{(circuito[}\StringTok{'dominio'}\NormalTok{], intersection)}
\ControlFlowTok{return}\NormalTok{ costo}
\end{Highlighting}
\end{Shaded}

Una volta eseguita questa conversione è stato possibile ottenere tutti i valori di costo sia dei circuiti booleani che di quelli binari.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'calcolo_costi.csv'}\NormalTok{, }\StringTok{'a'}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
  \BuiltInTok{file}\NormalTok{.write(}
    \StringTok{'NOME CIRC;COSTO BOOLEANO;INPUT ALICE;INPUT BOB;}
\StringTok{    DOMINIO MULTIVALORE;COSTO MULTIVALORE;INPUT ALICEINPUT BOB}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
  \ControlFlowTok{for}\NormalTok{ blfmv }\KeywordTok{in}\NormalTok{ listdir(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
    \ControlFlowTok{if}\NormalTok{ blfmv.endswith(}\StringTok{'.mv'}\NormalTok{):}
\NormalTok{      circ_mv }\OperatorTok{=}\NormalTok{ info_circuito(}
          \StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv/synth'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir),blfmv)}
\NormalTok{      costo_mv }\OperatorTok{=}\NormalTok{ calcolo_costo_circuito(circ_mv)}
      \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(circ_mv[}\StringTok{'input'}\NormalTok{]) }\OperatorTok{%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{:}
\NormalTok{          alice_var_mv }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_mv[}\StringTok{'input'}\NormalTok{])}\OperatorTok{/} \DecValTok{2}\NormalTok{)}
\NormalTok{          bob_var_mv }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_mv[}\StringTok{'input'}\NormalTok{]) }\OperatorTok{/}\DecValTok{2}\NormalTok{) }\OperatorTok{+} \DecValTok{1}
      \ControlFlowTok{else}\NormalTok{:}
\NormalTok{          alice_var_mv }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_mv[}\StringTok{'input'}\NormalTok{])}\OperatorTok{/} \DecValTok{2}\NormalTok{)}
\NormalTok{          bob_var_mv }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_mv[}\StringTok{'input'}\NormalTok{]) }\OperatorTok{/}\DecValTok{2}\NormalTok{)}
\NormalTok{      circ_bool }\OperatorTok{=}\NormalTok{ info_circuito(}
          \StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blif/synth'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir), }\StringTok{'}\SpecialCharTok{\{\}}\StringTok{blif'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(blfmv.split(}\StringTok{'.'}\NormalTok{)[}\DecValTok{0}\NormalTok{]))}
\NormalTok{      costo_bool }\OperatorTok{=}\NormalTok{ calcolo_costo_circuito(circ_bool)}
      \ControlFlowTok{if} \BuiltInTok{len}\NormalTok{(circ_bool[}\StringTok{'input'}\NormalTok{]) }\OperatorTok{%} \DecValTok{2} \OperatorTok{!=} \DecValTok{0}\NormalTok{:}
\NormalTok{          alice_var_bool }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_boo[}\StringTok{'input'}\NormalTok{]) }\OperatorTok{/} \DecValTok{2}\NormalTok{)}
\NormalTok{          bob_var_bool }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_bool[}\StringTok{'input'}\NormalTok{) }\OperatorTok{/} \DecValTok{2}\NormalTok{) }\OperatorTok{+} \DecValTok{1}
      \ControlFlowTok{else}\NormalTok{:}
\NormalTok{          alice_var_bool }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_boo[}\StringTok{'input'}\NormalTok{]) }\OperatorTok{/} \DecValTok{2}\NormalTok{)}
\NormalTok{          bob_var_bool }\OperatorTok{=} \BuiltInTok{int}\NormalTok{(}\BuiltInTok{len}\NormalTok{(circ_bool[}\StringTok{'input'}\NormalTok{) }\OperatorTok{/} \DecValTok{2}\NormalTok{)}
      \BuiltInTok{file}\NormalTok{.write(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\StringTok{;}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.forma(}
\NormalTok{        blfmv.split(}\StringTok{'.'}\NormalTok{)[}\DecValTok{0}\NormalTok{], costo_bool, alice_var_bool,bob_var_bool, }
\NormalTok{          circ_mv[}\StringTok{'dominio'}\NormalTok{],costo_mv, alice_var_mv, bob_var_mv))}
\end{Highlighting}
\end{Shaded}

Ottenute tutte le informazioni, per avere una migliore visione per l'analisi, esse vengono salvate all'interno di una file \emph{CVS} con la funzione sopra mostrata.

\newpage

\hypertarget{automatizzazione-dei-processi}{%
\section{Automatizzazione dei processi}\label{automatizzazione-dei-processi}}

Tutte le fasi mostrate sopra, più altre secondarie, sono state automatizzate in modo tale che:

\begin{itemize}
\tightlist
\item
  non si debbano effettuare operazioni ridondati per ogni circuito
\item
  non si generino perdite di dati causate da errori umani.
\end{itemize}

\hypertarget{struttura}{%
\subsection{Struttura}\label{struttura}}

\begin{verbatim}
.
├── abc_alias.abc           #alias con metodi sintesi ABC
├── automate.py             #automatizzatore dei processi
├── calcolo_costi.csv
├── calcolo_costi_no_synth.csv
├── facili  #directory contenente i file d'analisi
│   ├── blfmv
│   │   └── synth # circuiti sintetizzati
│   ├── blif
│   │   └── synth
│   └── pla_extended #pla espansi per debugging
├── lib_mv  # libreria con tutti le funzioni create
│   ├── automate_mvsis.py
│   ├── bin_to_mv.py
│   └── caloclo_costo.py
├── pla_to_blif.mvsis   #file con sintesi per MVSIS
├── synth_bool.abc      #file di sintesi  binaria per ABC
└── synth_mv.abc        #file di sintesi multi valore per ABC
\end{verbatim}

\newpage

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{working_dir }\OperatorTok{=} \StringTok{'./prova'}
 \ControlFlowTok{if}\NormalTok{ path.exists(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blif'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)) }
    \KeywordTok{and}\NormalTok{ path.exists(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
\NormalTok{        rmtree(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blif'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}
\NormalTok{        rmtree(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}
      
\NormalTok{makedirs(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blif/synth'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}
\NormalTok{makedirs(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv/synth'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}
\NormalTok{makedirs(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv/synth/abc'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}
\NormalTok{makedirs(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv/synth/mvsis'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}

\ControlFlowTok{if}\NormalTok{ path.exists(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/synth_out.mvsis'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
\NormalTok{    remove(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/synth_out.mvsis'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir))}

\ControlFlowTok{if} \KeywordTok{not}\NormalTok{ path.exists(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/pla'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
    \BuiltInTok{print}\NormalTok{(}\StringTok{'CARTELLA PLA NON PRESENTE'}\NormalTok{)}
\NormalTok{    exit}
\end{Highlighting}
\end{Shaded}

In questa fase viene creata la struttura delle directory che conterranno i file con i circuiti sintetizzati. Nel caso in cui questa struttura fosse già presente, verranno cancellate tutte le cartelle e i file all'interno e successivamente ricreate le cartelle vuote.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bin_to_mv_mcd(working_dir)}
\ControlFlowTok{if}\NormalTok{ exists(}\StringTok{'./pla_to_blif.mvsis'}\NormalTok{):}
\NormalTok{  remove(}\StringTok{'./pla_to_blif.mvsis'}\NormalTok{)}
\NormalTok{pla_to_blif(working_dir)}
\end{Highlighting}
\end{Shaded}

\newpage

In questa sezione vengono chiamate due utility create con lo scopo di generare dei file utilizzabili sia da \textbf{ABC} che da \textbf{MVSIS}.

\begin{itemize}
\tightlist
\item
  \textbf{bin\_to\_mv\_mcd}: ha lo scopo di creare i file \emph{blfmv} di ogni circuito all'interno della directory di lavoro
\item
  \textbf{pla\_to\_blif}: prende dalla directory di lavoro i file \emph{pla} contenenti i circuiti e li converte in \emph{blif} per avere un formato identico di rappresentazione tra i circuiti binari e quelli multi valore.
\end{itemize}

\newpage

\hypertarget{pla_to_blif}{%
\subsubsection{pla\_to\_blif}\label{pla_to_blif}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ pla_to_blif(working_dir):}
  \ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'./pla_to_blif.mvsis'}\NormalTok{, }\StringTok{'w'}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \BuiltInTok{file}\NormalTok{.write(}\StringTok{"source abc_alias.abc}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ ele }\KeywordTok{in}\NormalTok{ os.listdir(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/pla'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
      \BuiltInTok{file}\NormalTok{.write(}\StringTok{'read_pla }\SpecialCharTok{\{\}}\StringTok{/pla/}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir,ele))}
      \BuiltInTok{file}\NormalTok{.write(}\StringTok{'write_blif }\SpecialCharTok{\{\}}\StringTok{/blif/}\SpecialCharTok{\{\}}\StringTok{.blif}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
\NormalTok{        working_dir, ele.split(}\StringTok{'.'}\NormalTok{)[}\DecValTok{0}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

Questa funzione restituisce un file leggibile come input da \emph{mvsis} o \emph{abc} in grado di cambiare automaticamente formato dei file da \emph{pla} a \emph{blif}. In questo modo la conversione viene fatta automaticamnte da uno dei programmi scelti senza ricorrere ad ulteriore codice o incappare in errori di conversione. Il file ottenuto ha la seguente struttura.

\begin{verbatim}
source abc_alias.abc
read_pla ./prova/pla/alu2.pla
write_blif ./prova/blif/alu2.blif

read_pla ./prova/pla/br2.pla
write_blif ./prova/blif/br2.blif

read_pla ./prova/pla/amd.pla
write_blif ./prova/blif/amd.blif
\end{verbatim}

In questo modo ogni circuito viene convertito semplicemente chiamando

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{call([}\StringTok{'abc'}\NormalTok{, }\StringTok{'-F'}\NormalTok{, }\StringTok{'./pla_to_blif.mvsis'}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\newpage

\hypertarget{bin_to_mv_mcd}{%
\subsubsection{bin\_to\_mv\_mcd}\label{bin_to_mv_mcd}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ bin_to_mv_mcd(working_dir):}
  \ControlFlowTok{for}\NormalTok{ pla }\KeywordTok{in}\NormalTok{ listdir(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/pla'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
    \ControlFlowTok{if}\NormalTok{ pla.endswith(}\StringTok{'.pla'}\NormalTok{):}
\NormalTok{      inp, out, inp_array, out_array, truth_table }\OperatorTok{=}\NormalTok{ read_pla(}
        \StringTok{'}\SpecialCharTok{\{\}}\StringTok{/pla/}\SpecialCharTok{\{\}}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir, pla))}
\NormalTok{      dv }\OperatorTok{=}\NormalTok{ euclide(}\BuiltInTok{int}\NormalTok{(inp), }\BuiltInTok{int}\NormalTok{(out))}
      \ControlFlowTok{if} \BuiltInTok{int}\NormalTok{(inp.strip()) }\OperatorTok{==} \BuiltInTok{int}\NormalTok{(out.strip()) }\KeywordTok{or}\NormalTok{ dv }\OperatorTok{==} \BuiltInTok{int}\NormalTok{(inp):}
\NormalTok{        dv }\OperatorTok{=}\NormalTok{ dv}\OperatorTok{/}\DecValTok{2}
      \ControlFlowTok{if}\NormalTok{ dv }\OperatorTok{>=} \DecValTok{8}\NormalTok{:}
\NormalTok{        dv }\OperatorTok{=} \DecValTok{2} 
\NormalTok{        mv }\OperatorTok{=} \BuiltInTok{pow}\NormalTok{(}\DecValTok{2}\NormalTok{, dv)}
        \BuiltInTok{print}\NormalTok{(}\StringTok{'}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{inp: }\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{out:}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{multi-valore:}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}
\StringTok{          divide ogni:}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(pla,inp.strip(), }
\NormalTok{          out.strip(), }\BuiltInTok{int}\NormalTok{(mv), }\BuiltInTok{int}\NormalTok{(dv)))}
\NormalTok{        truth_table }\OperatorTok{=}\NormalTok{ expand_dont_care(truth_table, }\BuiltInTok{int}\NormalTok{(dv))}
\NormalTok{        mv_table }\OperatorTok{=}\NormalTok{ create_mv_truth_table(truth_table, }\BuiltInTok{int}\NormalTok{(dv))}
\NormalTok{        crete_blif_mv(working_dir, mv_table, }\BuiltInTok{int}\NormalTok{(mv),}
\NormalTok{          basename(pla).split(}\StringTok{'.'}\NormalTok{)[}\DecValTok{0}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

In questa funzione vengono racchiuse le funzioni descritte precedentemente per la conversione del circuito da binario a multi valore e la creazione dei file utilizzabili dai motori di sintesi. Come descritto nei capitoli precedenti verranno utilizzate due tecniche di conversione in base al circuito, una statica e una dinamica. Di seguito verrà mostrata solo la soluzione dinamica in quanto più complessa ma dalla struttura analoga alla proposta statica.

\newpage

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dv }\OperatorTok{=}\NormalTok{ euclide(}\BuiltInTok{int}\NormalTok{(inp), }\BuiltInTok{int}\NormalTok{(out))}
  \ControlFlowTok{if} \BuiltInTok{int}\NormalTok{(inp.strip()) }\OperatorTok{==} \BuiltInTok{int}\NormalTok{(out.strip())}
    \KeywordTok{or}\NormalTok{ dv }\OperatorTok{==} \BuiltInTok{int}\NormalTok{(inp):}
\NormalTok{    dv }\OperatorTok{=}\NormalTok{ dv}\OperatorTok{/}\DecValTok{2}
  \ControlFlowTok{if}\NormalTok{ dv }\OperatorTok{>=} \DecValTok{8}\NormalTok{:}
\NormalTok{    dv }\OperatorTok{=} \DecValTok{2} 

\KeywordTok{def}\NormalTok{ euclide(a, b):}
  \ControlFlowTok{while}\NormalTok{(b }\OperatorTok{!=} \DecValTok{0}\NormalTok{):}
\NormalTok{    R }\OperatorTok{=}\NormalTok{ a }\OperatorTok{%}\NormalTok{ b}
\NormalTok{    a }\OperatorTok{=}\NormalTok{ b}
\NormalTok{    b }\OperatorTok{=}\NormalTok{ R}
  \ControlFlowTok{return}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

In questa porzione avvengono le fasi di individuazione del M.C.D. tramite la funzione \emph{euclide} e viene effettuato il controllo nel caso in cui il dominio trovato fosse troppo grande o che ci fosse un solo input utilizzando questo dominio.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{synth(working_dir)}

\NormalTok{call([}\StringTok{'abc'}\NormalTok{, }\StringTok{'-F'}\NormalTok{, }\StringTok{'./synth_bool.abc'}\NormalTok{])}
\NormalTok{call([}\StringTok{'abc'}\NormalTok{, }\StringTok{'-F'}\NormalTok{, }\StringTok{'./synth_mv.abc'}\NormalTok{])}
\NormalTok{call([}\StringTok{'mvsis'}\NormalTok{, }\StringTok{'-F'}\NormalTok{, }\StringTok{'./synth_mv.mvsis'}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

L'ultimo passo consiste nella sintesi dei circuiti ottenuti e nella loro controparte binaria, la funzione \texttt{synth} fa in modo che vengano creati 2 file da dare in ingresso ad \texttt{MVSIS} o \texttt{ABC} che sintetizzino tutti i circuiti e salvino il risultato in dei file.

\hypertarget{synth}{%
\subsubsection{Synth}\label{synth}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ synth(working_dir):  }
  \ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'./synth_bool.abc'}\NormalTok{, }\StringTok{'w'}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \BuiltInTok{file}\NormalTok{.write(}\StringTok{"source abc_alias.abc}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ ele }\KeywordTok{in}\NormalTok{ os.listdir(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blif'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
      \ControlFlowTok{if}\NormalTok{ ele.endswith(}\StringTok{'.blif'}\NormalTok{):}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'read_blif }\SpecialCharTok{\{\}}\StringTok{/blif/}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir,ele))}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'cl}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'resyn2}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'cl}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'write_blif }\SpecialCharTok{\{\}}\StringTok{/blif/synth/}\SpecialCharTok{\{\}}\StringTok{.blif}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
\NormalTok{          working_dir,ele.split(}\StringTok{'.'}\NormalTok{)[}\DecValTok{0}\NormalTok{]))}
  \ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'./synth_mv.abc'}\NormalTok{, }\StringTok{'w'}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \BuiltInTok{file}\NormalTok{.write(}\StringTok{"source abc_alias.abc}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ ele }\KeywordTok{in}\NormalTok{ os.listdir(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
      \ControlFlowTok{if}\NormalTok{ ele.endswith(}\StringTok{'.mv'}\NormalTok{):}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'read_blif_mv }\SpecialCharTok{\{\}}\StringTok{/blfmv/}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}
\NormalTok{          .}\BuiltInTok{format}\NormalTok{(working_dir, ele))}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'strash}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'compress2}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'cl}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'resyn2}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'cl}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'write_blif_mv }\SpecialCharTok{\{\}}\StringTok{/blfmv/synth/abc/}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dele))}
  \ControlFlowTok{with} \BuiltInTok{open}\NormalTok{(}\StringTok{'./synth_mv.mvsis'}\NormalTok{, }\StringTok{'w'}\NormalTok{) }\ImportTok{as} \BuiltInTok{file}\NormalTok{:}
    \ControlFlowTok{for}\NormalTok{ ele }\KeywordTok{in}\NormalTok{ os.listdir(}\StringTok{'}\SpecialCharTok{\{\}}\StringTok{/blfmv'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(working_dir)):}
      \ControlFlowTok{if}\NormalTok{ ele.endswith(}\StringTok{'.mv'}\NormalTok{):}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'read_blif_mv }\SpecialCharTok{\{\}}\StringTok{/blfmv/}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{.}\BuiltInTok{format}\NormalTok{(}
\NormalTok{          working_dir, ele)}
\NormalTok{        )}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'sweep}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'eliminate -l 1}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'simplify -m nocomp}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'eliminate -l 1}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'sweep}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'eliminate -l 5}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'simplify}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'sweep}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'eliminate -l 1}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'sweep}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'fullsimp -m nocomp}\CharTok{\textbackslash{}n}\StringTok{'}\NormalTok{)}
        \BuiltInTok{file}\NormalTok{.write(}\StringTok{'write_blif_mv }\SpecialCharTok{\{\}}\StringTok{/blfmv/synth/mvsis/}\SpecialCharTok{\{\}}\CharTok{\textbackslash{}n\textbackslash{}n}\StringTok{'}
\NormalTok{          .}\BuiltInTok{format}\NormalTok{(working_dir, ele))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{synth\_bool}: crea il file per la sintesi utilizzata da \textbf{ABC} per i circuiti booleani;
\item
  \textbf{synth\_mv.abc}: crea il file per la sintesi utilizzata da \textbf{ABC} per i circuiti multi valore;
\item
  \textbf{synth\_mv}: crea il file per la sintesi utilizzata da \textbf{MVSIS} per i circuiti multi valore;
\end{itemize}

\newpage

Viene poi controllato se è già presente un file contenente dei costi e, se c'è, lo elimina

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ exists(}\StringTok{'./calcolo_costi.csv'}\NormalTok{):}
\NormalTok{    remove(}\StringTok{'./calcolo_costi.csv'}\NormalTok{)}
\ControlFlowTok{if}\NormalTok{ exists(}\StringTok{'./calcolo_costi_no_synth.csv'}\NormalTok{):}
\NormalTok{    remove(}\StringTok{'./calcolo_costi_no_synth.csv'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Infine i costi dei circuiti possono essere calcolati

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{calcolo_costi_synth(working_dir)}
\NormalTok{calcolo_costi_no_synth(working_dir)}

\KeywordTok{def}\NormalTok{ calcolo_costo_circuito(circuito):}
\NormalTok{  costo }\OperatorTok{=} \DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ t }\KeywordTok{in}\NormalTok{ circuito[}\StringTok{'tabelle'}\NormalTok{]:}
\NormalTok{    intersection }\OperatorTok{=} \BuiltInTok{len}\NormalTok{(}\BuiltInTok{set}\NormalTok{(circuito[}\StringTok{'input'}\NormalTok{]).intersection(t[}\StringTok{'input'}\NormalTok{]))}
\NormalTok{    costo }\OperatorTok{=}\NormalTok{ costo }\OperatorTok{+} \BuiltInTok{pow}\NormalTok{(circuito[}\StringTok{'dominio'}\NormalTok{], intersection)}
  \ControlFlowTok{return}\NormalTok{ costo}
\end{Highlighting}
\end{Shaded}

Le operazioni di calcolo del costo vengono effettuate e, infine, viene generato il file \emph{CSV} contenente i risultati.

\hypertarget{risultati-sperimentali}{%
\chapter{Risultati sperimentali}\label{risultati-sperimentali}}

Una volta concluso il processo di conversione dei circuiti e terminato tutto il sistema di automazione dei processi, si è proceduto con l'analisi sperimentale dei dati raccolti, in modo tale da valutare se questo nuovo approccio sviluppato potesse essere considerato una alternativa possibile o vincente rispetto alle proposte già presenti in letteratura.

Tutte le operazioni computazionali sono state effettuate utilizzando un DELL-XPS 13 9350, la macchina ha le seguenti specifiche:

\begin{itemize}
\tightlist
\item
  Processore: Intel \href{mailto:i5-6200U@2.30GHz}{\nolinkurl{i5-6200U@2.30GHz}} con 2 core e 4 thread
\item
  Memoria: 8Gb \href{mailto:LPDDR3@1866MHz}{\nolinkurl{LPDDR3@1866MHz}}
\item
  Sistema Operativo: Ubuntu 21.04
\end{itemize}

\newpage

\hypertarget{mvsis-2}{%
\section{MVSIS}\label{mvsis-2}}

Nelle prime fasi di sperimentazione si e' decido di utilizzare MVSIS come motore di sintesi, sia per i circuiti binari che per quelli multi valore. Questo primo approccio è nato dalla volontà di replicare le operazioni che si svolgono solitamente sulla logica binaria per poi applicarle alla logica multi valore.

Per le operazioni di sintesi si sono utilizzati i seguenti comandi:

\begin{verbatim}
read_blif_mv ./prova/blfmv/amd.mv
sweep
eliminate -l 1
simplify -m nocomp
eliminate -l 1
sweep
eliminate -l 5
simplify
sweep
eliminate -l 1
sweep
fullsimp -m nocomp
write_blif_mv ./prova/blfmv/synth/mvsis/amd.mv
\end{verbatim}

Con questi comandi si va ad attuare una sintesi del circuito preso in ingresso, nello specifico vengono effettuate tutte le operazioni necessarie di pulizia e di rimozione di nodi inutili tramite i comandi \emph{eliminate} e \emph{sweep}. Successivamente, tramite \emph{simplify} e \emph{fullsimp}, il circuito viene semplificato su due livelli: sia per quanto concerne i nodi presenti all'interno del circuito, sia per quanto riguarda il circuito stesso nella sua interezza.

Questi comandi sono la conversione della variante \textbf{MVSIS} di \emph{script.rugged} usato con il tool per la logica binaria SIS. In questo caso, però, Non è stato possibile operare una conversione 1:1 dello script in quanto non tutti i comandi sono replicabili.

Per far fronte alla mancanza di replicabilità di alcuni comandi in questo sistema, è stato necessario eseguire un'ulteriore ricerca Sia in rete che in altri paper riguardanti l'argomento. Quello che ne viene dedotto è che è stato creato ed esiste un determinato script, chiamato \emph{mvsis.rugged} che, secondo la nostra ricerca, dovrebbe rappresentare la vera conversione adattata per il multi valore. Purtroppo però non è stato possibile in alcun modo reperire questo file in nessun repository, rendendolo quindi per noi non utilizzabile ai fini delle analisi.

\newpage

\hypertarget{conversione-multi-valore-fissa}{%
\subsection{Conversione multi valore fissa}\label{conversione-multi-valore-fissa}}

Come primo approccio alla conversione da binaria a multi valore abbiamo optato per lo stesso valore di dominio per tutti i circuiti. La scelta è stata quella di andare ad aggiungere altri 2 valori rispetto a ad un circuito binario utilizzando il modulo 3.

\begin{longtable}[]{@{}llllllll@{}}
\toprule
CIRC & COSTO & ALICE & BOB & COSTO & ALICE & BOB & \% Guadagno\tabularnewline
\midrule
\endhead
amd & 469 & 7 & 7 & 47568 & 3 & 4 & -10042\%\tabularnewline
tms & 322 & 4 & 4 & 2048 & 2 & 2 & -536\%\tabularnewline
pdc & 2818 & 7 & 7 & 1310720 & 4 & 4 & -46412\%\tabularnewline
mlp4 & 594 & 4 & 4 & 784 & 2 & 2 & -32\%\tabularnewline
apla & 343 & 5 & 5 & 1029 & 2 & 3 & -200\%\tabularnewline
f51m & 261 & 4 & 4 & 340 & 2 & 2 & -30\%\tabularnewline
m4 & 974 & 4 & 4 & 1601 & 2 & 2 & -64\%\tabularnewline
newtpla2 & 48 & 5 & 5 & 2048 & 2 & 3 & -4167\%\tabularnewline
test1 & 1095 & 4 & 4 & 1280 & 2 & 2 & -17\%\tabularnewline
m2 & 339 & 4 & 4 & 1121 & 2 & 2 & -231\%\tabularnewline
br2 & 179 & 6 & 6 & 16384 & 3 & 3 & -9053\%\tabularnewline
alu1 & 83 & 6 & 6 & 5122 & 3 & 3 & -6071\%\tabularnewline
sqr6 & 197 & 3 & 3 & 276 & 1 & 2 & -40\%\tabularnewline
bench & 198 & 3 & 3 & 256 & 1 & 2 & -29\%\tabularnewline
in5 & 446 & 7 & 7 & 117440512 & 6 & 6 & -26331853\%\tabularnewline
newtpla1 & 33 & 5 & 5 & 1024 & 2 & 3 & -3003\%\tabularnewline
m3 & 571 & 4 & 4 & 1169 & 2 & 2 & -105\%\tabularnewline
newapla & 83 & 6 & 6 & 9728 & 3 & 3 & -11620\%\tabularnewline
l8err & 454 & 4 & 4 & 337 & 2 & 2 & 26\%\tabularnewline
t4 & 238 & 6 & 6 & 10240 & 3 & 3 & -4203\%\tabularnewline
br1 & 252 & 6 & 6 & 16384 & 3 & 3 & -6402\%\tabularnewline
fout & 442 & 3 & 3 & 320 & 1 & 2 & 28\%\tabularnewline
mp2d & 136 & 7 & 7 & 7 & 3 & 4 & 95\%\tabularnewline
alu2 & 225 & 5 & 5 & 1282 & 2 & 3 & -470\%\tabularnewline
t3 & 131 & 6 & 6 & 4 & 3 & 3 & 97\%\tabularnewline
p3 & 385 & 4 & 4 & 1408 & 2 & 2 & -266\%\tabularnewline
m1 & 125 & 3 & 3 & 225 & 1 & 2 & -80\%\tabularnewline
bcd\_div3 & 54 & 2 & 2 & 32 & 1 & 1 & 41\%\tabularnewline
alu3 & 139 & 5 & 5 & 4 & 2 & 3 & 97\%\tabularnewline
in7 & 182 & 7 & 7 & 23085056 & 6 & 7 & -12683997\%\tabularnewline
& \textbf{393,87} & \textbf{4,87} & \textbf{4,87} & \textbf{4731943,63} & \textbf{2,43} & \textbf{2,83} & \textbf{-13039,51}\tabularnewline
& \textbf{MEDIA} & & & \textbf{MEDIA} & & &\tabularnewline
\bottomrule
\end{longtable}

Questa tabella racchiude i risultati ottenuti dalla sintesi dei circuiti multi valore e dei circuiti binari. Possiamo notare che nella maggior parte dei casi il circuito binario mantiene ancora una grande efficienza rispetto a quello multi valore.

\hypertarget{mvsis-e-dominio-variabile}{%
\subsection{MVSIS e dominio variabile}\label{mvsis-e-dominio-variabile}}

Nella sperimentazione successiva si è voluto testare un dominio variabile in base al MCD, come descritto nel capitolo precedente. Nella seguente tabella vengono mostrati i costi dei circuiti senza sintesi. Possiamo osservare che nella maggior parte dei casi il dominio multi valore senza sintesi ha un costo minore. Questo risultato può essere considerato una conseguenza diretta del minor numero di input che le parti dovranno inserire all'interno del protocollo durante la computazione. Questi input, essendo in minor quantità, rendono l'intero processo di sintesi più leggero e meno costoso.

\begin{longtable}[]{@{}llllll@{}}
\toprule
NOME CIRC & DOMINIO & COSTO & ALICE & BOB & \% GUADAGNO\tabularnewline
\midrule
\endhead
amd & 4 & 196608 & 3 & 4 & 50\%\tabularnewline
tms & 16 & 1024 & 1 & 1 & 75\%\tabularnewline
pdc & 4 & 1310720 & 4 & 4 & 50\%\tabularnewline
mlp4 & 16 & 512 & 1 & 1 & 75\%\tabularnewline
apla & 4 & 6144 & 2 & 3 & 50\%\tabularnewline
f51m & 16 & 512 & 1 & 1 & 75\%\tabularnewline
m4 & 16 & 1024 & 1 & 1 & 75\%\tabularnewline
newtpla2 & 4 & 2048 & 2 & 3 & 50\%\tabularnewline
test1 & 4 & 1280 & 2 & 2 & 50\%\tabularnewline
m2 & 16 & 1024 & 1 & 1 & 75\%\tabularnewline
br2 & 16 & 8192 & 1 & 2 & 75\%\tabularnewline
alu1 & 16 & 8192 & 1 & 2 & 75\%\tabularnewline
sqr6 & 8 & 256 & 1 & 1 & 64\%\tabularnewline
bench & 4 & 256 & 1 & 2 & 50\%\tabularnewline
in5 & 4 & 117440512 & 6 & 6 & -6300\%\tabularnewline
newtpla1 & 4 & 1024 & 2 & 3 & 50\%\tabularnewline
m3 & 16 & 1024 & 1 & 1 & 75\%\tabularnewline
newapla & 4 & 20480 & 3 & 3 & 50\%\tabularnewline
l8err & 16 & 512 & 1 & 1 & 60\%\tabularnewline
t4 & 16 & 8192 & 1 & 2 & 75\%\tabularnewline
br1 & 16 & 8192 & 1 & 2 & 75\%\tabularnewline
fout & 4 & 320 & 1 & 2 & 50\%\tabularnewline
mp2d & 128 & 32768 & 1 & 1 & 86\%\tabularnewline
alu2 & 4 & 4096 & 2 & 3 & 50\%\tabularnewline
t3 & 16 & 8192 & 1 & 2 & 75\%\tabularnewline
p3 & 4 & 1792 & 2 & 2 & 42\%\tabularnewline
m1 & 8 & 256 & 1 & 1 & 67\%\tabularnewline
bcd\_div3 & 4 & 32 & 1 & 1 & 50\%\tabularnewline
alu3 & 4 & 4096 & 2 & 3 & 50\%\tabularnewline
in7 & 4 & 335544320 & 6 & 7 & -25500\%\tabularnewline
& & \textbf{15153786,67} & \textbf{1,80} & \textbf{2,27} & \textbf{-10,02}\tabularnewline
& & \textbf{MEDIA} & & &\tabularnewline
\bottomrule
\end{longtable}

\newpage

Una vota applicato la sintesi dei circuiti i risultati sono i seguenti:

\begin{longtable}[]{@{}lllllll@{}}
\toprule
NOME CIRC & COSTO & DOMINIO & COSTO & ALICE & BOB & \% GUADAGNO\tabularnewline
\midrule
\endhead
amd & 469 & 4 & 47568 & 3 & 4 & -10042\%\tabularnewline
tms & 322 & 16 & 1024 & 1 & 1 & -218\%\tabularnewline
pdc & 2818 & 4 & 1310720 & 4 & 4 & -46412\%\tabularnewline
mlp4 & 594 & 16 & 512 & 1 & 1 & 14\%\tabularnewline
apla & 343 & 4 & 1029 & 2 & 3 & -200\%\tabularnewline
f51m & 261 & 16 & 272 & 1 & 1 & -4\%\tabularnewline
m4 & 974 & 16 & 1024 & 1 & 1 & -5\%\tabularnewline
newtpla2 & 48 & 4 & 2048 & 2 & 3 & -4167\%\tabularnewline
test1 & 1095 & 4 & 1280 & 2 & 2 & -17\%\tabularnewline
m2 & 339 & 16 & 1024 & 1 & 1 & -202\%\tabularnewline
br2 & 179 & 16 & 8192 & 1 & 2 & -4477\%\tabularnewline
alu1 & 83 & 16 & 4097 & 1 & 2 & -4836\%\tabularnewline
sqr6 & 197 & 8 & 200 & 1 & 1 & -2\%\tabularnewline
bench & 198 & 4 & 256 & 1 & 2 & -29\%\tabularnewline
in5 & 446 & 4 & 1,17E+08 & 6 & 6 & -26331853\%\tabularnewline
newtpla1 & 33 & 4 & 1024 & 2 & 3 & -3003\%\tabularnewline
m3 & 571 & 16 & 1024 & 1 & 1 & -79\%\tabularnewline
newapla & 83 & 4 & 9728 & 3 & 3 & -11620\%\tabularnewline
l8err & 454 & 16 & 512 & 1 & 1 & -13\%\tabularnewline
t4 & 238 & 16 & 8192 & 1 & 2 & -3342\%\tabularnewline
br1 & 252 & 16 & 8192 & 1 & 2 & -3151\%\tabularnewline
fout & 442 & 4 & 320 & 1 & 2 & 28\%\tabularnewline
mp2d & 136 & 3 & 7 & 3 & 4 & 95\%\tabularnewline
alu2 & 225 & 3 & 1282 & 2 & 3 & -470\%\tabularnewline
t3 & 131 & 3 & 4 & 3 & 3 & 97\%\tabularnewline
p3 & 385 & 3 & 1408 & 2 & 2 & -266\%\tabularnewline
m1 & 125 & 3 & 225 & 1 & 2 & -80\%\tabularnewline
bcd\_div3 & 54 & 3 & 32 & 1 & 1 & 41\%\tabularnewline
alu3 & 139 & 3 & 4 & 2 & 3 & 97\%\tabularnewline
in7 & 182 & 3 & 23085056 & 6 & 7 & -12683997\%\tabularnewline
& \textbf{393,87} & & \textbf{4716541,87} & \textbf{1,93} & \textbf{2,43} &\tabularnewline
& \textbf{MEDIA} & & \textbf{MEDIA} & & &\tabularnewline
\bottomrule
\end{longtable}

I costi vengono notevolmente abbassati nel caso del booleano mentre in quello multi valore rimangono più elevati. Analizzando Questo fenomeno potremmo trovare una spiegazione nel fatto che la sintesi sui circuiti binari è nettamente più sviluppata e sono stati scoperti metodi di sintesi più efficaci rispetto a quelli studiati per una logica multi valore.
Il tool MVSIS infatti, come affermato in precedenza, non è più stato sviluppato ne mantenuto. All'atto pratico si presenta infatti più lento nella sintesi ed ha una gestione della memoria che porta a dump di memoria durante l'analisi di circuiti di grandi dimensioni.

\newpage

\hypertarget{abc-2}{%
\section{ABC}\label{abc-2}}

Avendo potuto appurare che, inizialmente il costo del circuito multi valore possiede dei costi più bassi per via del minor numero di input, ma che la logica binaria può appoggiarsi a degli strumenti di sintesi più ottimizzati, si è provato ad utilizzare un approccio ibrido tra i due.

Sfruttando quindi come input un circuito multi valore ad ABC, questo tool è in grado di convertire automaticamente il circuito da multi valore a binario, in modo tale da poter utilizzare i suoi algoritmi di sintesi nettamente più ottimizzati.

\begin{verbatim}
read_blif_mv ./prova/blfmv/amd.mv
strash
compress2
cl
resyn2
cl
write_blif_mv ./prova/blfmv/synth/abc/amd.mv
\end{verbatim}

Rispetto a prima però vi sarà la differenza che l'output post sintesi non sarà più un circuito multi valore, bensì uno binario.

\newpage

\hypertarget{abc-e-dominio-fisso}{%
\section{ABC e dominio fisso}\label{abc-e-dominio-fisso}}

Come con \emph{MVSIS} è stato inizialmente utilizzato un dominio fisso per svolgere una prima analisi.

\begin{longtable}[]{@{}llllll@{}}
\toprule
NOME CIRC & COSTO & ALICE & BOB & COSTO & \% GUADAGNO\tabularnewline
\midrule
\endhead
amd & 469 & 7 & 7 & 1860 & -297\%\tabularnewline
tms & 322 & 4 & 4 & 198 & 39\%\tabularnewline
pdc & 2818 & 7 & 7 & 6032 & -114\%\tabularnewline
mlp4 & 594 & 4 & 4 & 764 & -29\%\tabularnewline
apla & 343 & 5 & 5 & 213 & 38\%\tabularnewline
f51m & 261 & 4 & 4 & 808 & -210\%\tabularnewline
m4 & 974 & 4 & 4 & 643 & 34\%\tabularnewline
newtpla2 & 48 & 5 & 5 & 48 & 0\%\tabularnewline
test1 & 1095 & 4 & 4 & 354 & 68\%\tabularnewline
m2 & 339 & 4 & 4 & 320 & 6\%\tabularnewline
br2 & 179 & 6 & 6 & 110 & 39\%\tabularnewline
alu1 & 83 & 6 & 6 & 83 & 0\%\tabularnewline
sqr6 & 197 & 3 & 3 & 263 & -34\%\tabularnewline
bench & 198 & 3 & 3 & 47 & 76\%\tabularnewline
in5 & 446 & 7 & 7 & 1336 & -200\%\tabularnewline
newtpla1 & 33 & 5 & 5 & 33 & 0\%\tabularnewline
m3 & 571 & 4 & 4 & 381 & 33\%\tabularnewline
newapla & 83 & 6 & 6 & 81 & 2\%\tabularnewline
l8err & 454 & 4 & 4 & 434 & 4\%\tabularnewline
t4 & 238 & 6 & 6 & 197 & 17\%\tabularnewline
br1 & 252 & 6 & 6 & 153 & 39\%\tabularnewline
fout & 442 & 3 & 3 & 214 & 52\%\tabularnewline
mp2d & 136 & 7 & 7 & 315 & -132\%\tabularnewline
alu2 & 225 & 5 & 5 & 554 & -146\%\tabularnewline
t3 & 131 & 6 & 6 & 160 & -22\%\tabularnewline
p3 & 385 & 4 & 4 & 139 & 64\%\tabularnewline
m1 & 125 & 3 & 3 & 116 & 7\%\tabularnewline
bcd\_div3 & 54 & 2 & 2 & 46 & 15\%\tabularnewline
alu3 & 139 & 5 & 5 & 406 & -192\%\tabularnewline
in7 & 182 & 7 & 7 & 1676 & -821\%\tabularnewline
& \textbf{393,87} & \textbf{4,87} & \textbf{4,87} & \textbf{599,47} & \textbf{-0,55}\tabularnewline
& \textbf{MEDIA} & & & \textbf{MEDIA} &\tabularnewline
\bottomrule
\end{longtable}

E' ora possibile notare come i risultati siano già migliorati e, in molti casi, la sintesi del circuito multi valore risulti essere migliore di quella binaria, tranne in sporadici casi.

\hypertarget{abc-e-dominio-variabile}{%
\section{ABC e dominio variabile}\label{abc-e-dominio-variabile}}

Come ultimo test, come in MVSIS, abbiamo deciso di applicare anche l'approccio MCD.

\begin{longtable}[]{@{}llllll@{}}
\toprule
NOME CIRC & BOOL & ALICE & BOB & COSTO & \% GUADAGNO\tabularnewline
\midrule
\endhead
amd & 469 & 7 & 7 & 1860 & -297\%\tabularnewline
tms & 322 & 4 & 4 & 184 & 43\%\tabularnewline
pdc & 2818 & 7 & 7 & 6032 & -114\%\tabularnewline
mlp4 & 594 & 4 & 4 & 669 & -13\%\tabularnewline
apla & 343 & 5 & 5 & 213 & 38\%\tabularnewline
f51m & 261 & 4 & 4 & 344 & -32\%\tabularnewline
m4 & 974 & 4 & 4 & 658 & 32\%\tabularnewline
newtpla2 & 48 & 5 & 5 & 48 & 0\%\tabularnewline
test1 & 1095 & 4 & 4 & 354 & 68\%\tabularnewline
m2 & 339 & 4 & 4 & 350 & -3\%\tabularnewline
br2 & 179 & 6 & 6 & 130 & 27\%\tabularnewline
alu1 & 83 & 6 & 6 & 774 & -833\%\tabularnewline
sqr6 & 197 & 3 & 3 & 234 & -19\%\tabularnewline
bench & 198 & 3 & 3 & 47 & 76\%\tabularnewline
in5 & 446 & 7 & 7 & 1336 & -200\%\tabularnewline
newtpla1 & 33 & 5 & 5 & 33 & 0\%\tabularnewline
m3 & 571 & 4 & 4 & 388 & 32\%\tabularnewline
newapla & 83 & 6 & 6 & 81 & 2\%\tabularnewline
l8err & 454 & 4 & 4 & 338 & 26\%\tabularnewline
t4 & 238 & 6 & 6 & 248 & -4\%\tabularnewline
br1 & 252 & 6 & 6 & 136 & 46\%\tabularnewline
fout & 442 & 3 & 3 & 214 & 52\%\tabularnewline
mp2d & 136 & 7 & 7 & 1677 & -1133\%\tabularnewline
alu2 & 225 & 5 & 5 & 554 & -146\%\tabularnewline
t3 & 131 & 6 & 6 & 354 & -170\%\tabularnewline
p3 & 385 & 4 & 4 & 139 & 64\%\tabularnewline
m1 & 125 & 3 & 3 & 112 & 10\%\tabularnewline
bcd\_div3 & 54 & 2 & 2 & 46 & 15\%\tabularnewline
alu3 & 139 & 5 & 5 & 406 & -192\%\tabularnewline
in7 & 182 & 7 & 7 & 1676 & -821\%\tabularnewline
& 393,87 & 4,87 & 4,87 & 654,50 & -1,15\tabularnewline
& MEDIA & & & MEDIA &\tabularnewline
\bottomrule
\end{longtable}

In questo caso possiamo appurare che tra i due approcci non ci sono differenze sostanziali, questo risultato potrebbe essere derivato dalle modalità con cui ABC legge i circuiti multi valore in input.

\hypertarget{conclusioni}{%
\chapter{Conclusioni}\label{conclusioni}}

Una volta terminate tutte le analisi e le sperimentazioni eseguite sui circuiti binari e multi valore siamo stati in grado di trarre alcune informazioni molto importanti riguardanti essi e i loro funzionamenti. Tutti i dati ottenuti da questa sperimentazione ci hanno portati a notare come l'utilizzo della logica multi valore all'interno dei circuiti potrebbe rivelarsi molto interessante in termini di riduzione dei costi relativi ai valori di input che sono richiesti dai circuiti.

La limitazione principale che abbiamo potuto riscontrare è insita nella carenza di strumenti di sintesi a disposizione che possano essere considerati applicabili alla logica multi valore. Come anticipato, solamente \textbf{MVSIS} è in grado di gestire e interpretare questo tipo di logica, ma rimane un programma ora mai datato e non più mantenuto, di conseguenza non vi sono al suo interno tool sufficientemente aggiornati o meglio implementati. I nuovi strumenti messi a disposizione, come ad esempio \textbf{ABC}, accettano in ingresso circuiti multi valore ma, per poter fare questo, nel loro motore di sintesi essi vengono convertiti in circuiti booleani. L'efficienza e l'efficacia delle nuove funzioni di sintesi attuate da \textbf{ABC} hanno reso l'utilizzo di questo software la prima scelta da utilizzare nel caso di circuiti multi valore e binari.

Applicando un approccio ibrido siamo stati in grado di prendere il meglio dei sintetizzatori presentati. Sfruttando la riduzione degli input durante la conversione in un dominio maggiore di quello binario combinata all'alta efficacia degli strumenti di sintesi messi a disposizione di \textbf{ABC} abbiamo ottenuto i risultati migliori.

\newpage

\begin{longtable}[]{@{}llllll@{}}
\toprule
\textbf{Circuito} & \textbf{BIN} & \textbf{MV} & \textbf{MVSIS var} & \textbf{ABC var} & \textbf{RIDUZ \%}\tabularnewline
\midrule
\endhead
amd & 393216 & 196608 & 47568 & 1860 & 96,09\%\tabularnewline
tms & 4096 & 1024 & 1024 & 184 & 82,03\%\tabularnewline
pdc & 2621440 & 1310720 & 1310720 & 6032 & 99,54\%\tabularnewline
mlp4 & 2048 & 512 & 512 & 669 & -30,66\%\tabularnewline
apla & 12288 & 6144 & 1029 & 213 & 79,30\%\tabularnewline
f51m & 2048 & 512 & 272 & 344 & -26,47\%\tabularnewline
m4 & 4096 & 1024 & 1024 & 658 & 35,74\%\tabularnewline
newtpla2 & 4096 & 2048 & 2048 & 48 & 97,66\%\tabularnewline
test1 & 2560 & 1280 & 1280 & 354 & 72,34\%\tabularnewline
m2 & 4096 & 1024 & 1024 & 350 & 65,82\%\tabularnewline
br2 & 32768 & 8192 & 8192 & 130 & 98,41\%\tabularnewline
alu1 & 32768 & 8192 & 4097 & 774 & 81,11\%\tabularnewline
sqr6 & 705 & 256 & 200 & 234 & -17,00\%\tabularnewline
bench & 512 & 256 & 256 & 47 & 81,64\%\tabularnewline
in5 & 1835008 & 117440512 & 117440512 & 1336 & 100,00\%\tabularnewline
newtpla1 & 2048 & 1024 & 1024 & 33 & 96,78\%\tabularnewline
m3 & 4096 & 1024 & 1024 & 388 & 62,11\%\tabularnewline
newapla & 40960 & 20480 & 9728 & 81 & 99,17\%\tabularnewline
l8err & 1283 & 512 & 512 & 338 & 33,98\%\tabularnewline
t4 & 32768 & 8192 & 8192 & 248 & 96,97\%\tabularnewline
br1 & 32768 & 8192 & 8192 & 136 & 98,34\%\tabularnewline
fout & 640 & 320 & 320 & 214 & 33,13\%\tabularnewline
\textbf{MEDIA} & & & & & 65,27\%\tabularnewline
\bottomrule
\end{longtable}

\newpage

Questa tabella rappresenta la differenza di costo percentuale tra i due metodi più efficaci provati per ogni motore di sintesi.

Possiamo notare come questo tipo di metodica, definita ibrida, risulti essere il migliore approccio testato durante questa sperimentazione. E' possibile dimostrarlo in quanto i risultati mostrano una riduzione dei costi computazionali in tutti i casi ad eccezione di due, i restanti risultati hanno una percentuale di guadagno sempre superiore al 30\% e, nei casi di circuiti con grande quantità di nodi, anche superiore al 100\%; riducendo notevolmente il costo computazionale.

La tecnica di analisi ibrida offre i risultati migliori in quanto:

\begin{itemize}
\tightlist
\item
  La conversione di dominio ibrida al minimo dimezza i valori di input da inserire dalle parti e l'algoritmo fa in modo che non venga selezionato un dominio eccessivamente grande limitando le possibilità a casi utili in contesti reali;
\item
  \textbf{ABC} è un tool recente e sempre più ottimizzato, in continuo aggiornamento, e dispone di preset ottimizzati per la sintetizzazione dei circuiti.
\end{itemize}

La tabella riassume anche qual è stata l'evoluzione di questa analisi sperimentale: inizialmente ci si è concentrati su un metodo ottimale di conversione binaria e si è analizzato se effettivamente questa sperimentazione potesse avere dei reali benefici. Successivamente si è passati alla sintesi dei circuiti per capire se la sintesi di domini non binari potesse essere efficace come quella binaria. Una volta individuati i tool migliori si è cercato di capire quali tecniche di sintesi potessero essere le migliori, fino ad arrivare ai risultati finali con la constatazione che l'approccio ibrido, ad oggi, risulti la tecnica migliore da noi testata.

Lo studio dell'utilizzo della logica multi valore ha portato a dei risultati interessanti nonostante la limitazione data dalla scarsità e obsolescenza degli strumenti di sintesi. Le tecniche analizzate in un'ottica futura potranno affiancare le classiche metodologie binarie in quanto, analizzando i risultati, alcuni tipi di circuiti non giovano della conversione in multi valore generando costi maggiori rispetto alla controparte booleana.

\newpage

\bibliography{book.bib}

\end{document}
