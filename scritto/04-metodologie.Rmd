# Analisi

Il protocollo di Yao prevede, durante i suoi scambi, che le due parti concordino anche sulla trasmissione di un circuito a cui entrambi gli attori debbano inserire dei valori di input. Uno degli scopi della nostra tesi consiste nel testare l'efficacia dell'utilizzo di un multi valore rispetto all'utilizzo "classico" di un circuito booleano concentrandoci sul fattore di costo computazionale delle operazioni.

Siamo partiti quindi selezionando un set di circuiti binari con differente numero di ingressi, uscite e livelli. Con questa base ci si è poi concentrati sul trovare una metodologia di conversione dei circuiti per portarli da un 'classico' dominio booleano ad uno multi-valore dove i valori non sono più rappresentati sa 0 e 1 ma da da un set più ampio di valori ma mantenendo le funzionalità del circuito. Una volta ottenuta una controparte per ogni circuito si è proceduto con un confronto dei circuiti in modo da individuare quali di questi set siano più efficaci. 

\newpage

## Studio del circuito binario

Analizzando i circuiti per testare la nostra tesi abbiamo dovuto sviluppare una tecnica di conversione dei circuiti binari di partenza. Le caratteristiche di una naturale rappresentazione di un circuito consiste nella sua divisione in nodi, ognuno di essi rappresentato da una tabella di verità i cui input e output vanno a collegarsi tra di loro tramite dei collegamenti. Soffermandoci sulle tabelle di verità abbiamo notato come andando ad applicare un raggruppamento di $n$ bit per ogni riga della tabella si riuscirebbe a rappresentare un valore di dominio più grande di quello binario del circuito in analisi riducendo il numero di input richiesti dal gate.

$$\begin{matrix}
    \underbrace{10} & \underbrace{11} & \underbrace{00} \\
    \downarrow & \downarrow & \downarrow  &mod_3 \\
    2 & 3 & 0
\end{matrix}$$

Con questo approccio non andiamo a snaturare quella che è la logica della tabella originale poiché, sapendo il qual è il nuovo dominio applicato, riusciamo ad invertire il processo di conversione ritornando al circuito originale. 

I vincoli di questo approccio di conversione dei circuiti booleani risiede nel fatto che, per ora, la conversione possa essere fatta solamente con un numero pari di input e che il numero di output sia un divisore del numero di bit utilizzati per il raggruppamento.

\newpage

Una volta definito il metodo di conversione si è passati alla scelta del nuovo dominio da applicare ai circuiti con l'obiettivo di trovare il giusto compromesso per ottenere:

- Una riduzione degli input che faccia diminuire il costo del circuito di ingresso per il circuito di ingresso
- Utilizzare un dominio che risulti controproducente: avere un dominio superiore a quello booleano ma troppo elevato significherebbe che, per ogni input, ogni parte dovrebbe portare inserire tanti valori di input quanti quelli del dominio richiesto e, se si sceglie un dominio troppo grande, nonostante la riduzione degli input ci si troverebbe comunque con un costo totale del circuito elevato. Si è deciso quindi di sperimentare 2 approcci alla scelta di questo valore, uno statico e uno dinamico.

    - **Statico**: per ognuno dei circuiti andremo ad applicare lo stesso valore di dominio, il valore scelto è 3, andremo quindi a raggruppare ogni 2 valori per riga della tabella di verità;
    - **Dinamico**: ogni circuito viene analizzato andando a trovare il numero di input e output, successivamente viene calcolato il valore di M.C.D. e:
        - Se il valore trovato consente alla tabella di verità convertita di avere almeno 2 valori di input si utilizza quel valore per raggruppare i bit delle righe, altrimenti il valore viene dimezzato
        - Se il valore risultante è un numero che creerebbe un dominio troppo grande viene utilizzato il dominio 3, come nel caso statico.

Definite tutte le logiche di conversione si è dovuto cercare un formato di file che rappresentasse i circuiti che rispettasse le esigenze per applicare tutte le elaborazioni sopra descritte e che sia utilizzato come uno standard di rappresentazione in modo che i risultati ottenuti possano essere utilizzati dai software di sintesi che andremo ad utilizzare successivamente durante l'elaborazione della sperimentazione. Si necessita dunque di una rappresentazione che abbia la possibilità che i circuiti con output multipli siano rappresentati sulla stessa linea all'interno della tabella della verità.

Tra i vari formati a disposizione la scelta è ricaduta sul formato ```PLA``` già ampiamente utilizzato per la rappresentazione di circuiti.

\newpage

### Analisi della struttura PLA

Un file PLA ha la seguente struttura

```pla
.i 4
.o 2
.ilb x1 x2 y1 y2
.ob f1 f2
0--0 00    
0001 01
0-11 --
1-11 01
0101 10
10-- 01
11-- 00
.end
```

Questo `PLA` di esempio rappresenta un circuito composto da una sola tabella di verità, la sintassi va a descrivere:

- `.i`: numero di valori di input;
- `.o`: numero di valori di output;
- `.ilb`: nomi e ordine delle variabili di input;
- `.ob`: nomi e ordine delle variabili di output.

Il resto del file rappresenta la tabella di verità con i possibile valori che si ottengono combinando i valori di input_file per ottenere gli output.Il circuito sopra descritto presenta 4 variabili di input e 2 valori di output. Come possiamo notare all'interno della tabella di verità non tutti i valori sono booleani ma è presente anche il valore `-`, esso prende il nome di **don't care** e può assumere 2 significati:

- Quando `-` è presente negli output di una riga significa che l'output per quella determinata riga non mi interessa;
- Quando `-` è presente negli input significa che in quella posizione la variabile a cui fa riferimento può assumere un qualsiasi valore non andando ad influire sul valore di output che si andrà ad ottenere.

\newpage

### La gestione dei don't care durante la conversione

I dont't care sono una caratteristica dei file pla che deve essere gestita in modo funzionale ai cambi di dominio che andremo a fare all'interno delle tabelle di verità dei nostri circuiti in quanto, se affrontato nel modo sbagliato, modificherebbe la logica dell'intero circuito rendendo la conversione errata. Per spiegare meglio come tratteremo questa caratteristica dei **PLA** presenterò l'esempio di un esempio utilizzando un circuito semplice che come valore di dominio di conversione il valore 3. Il circuito avrà la seguente struttura.

```
.i 4
.o 2
.ilb x1 x2 y1 y2
.ob f1 f2
0--0 00    
0001 01
0-11 --
1-11 01
0101 10
10-- 01
11-- 00
.end
```

Una volta deciso il nostro nuovo dominio di conversione sappiamo di quanti bit dobbiamo raggruppare per rappresentare il nostro nuovo dominio, nel nostro caso essendo il domino 3, il numero di bit per rappresentare il valore più grande di questo dominio abbiamo bisogno di un raggruppamento a 2 bit. Procediamo quindi a scandire riga per riga il circuito raggruppando i bit a blocchi di 2 tutti i valori di input e di output.

```
0- -0 00    
00 01 01
0- 11 --
1- 11 01
01 01 10
10 -- 01
11 -- 00
```

Una volta creati questi cluster di bit ci accorgiamo come i dont't care in alcuni casi ci rendano impossibile la conversione al nuovo dominio, per risolvere questo problema dovremo andare a sviluppare questi valori di don't care in 'normali' valori booleani.

\newpage

Non è sempre necessario andare a sviluppare i don't care, andiamo a differenziare 2 possibili casistiche di intervento:

- Quando il numero di '-' è uguale al numero di bit del raggruppamento multivalore, in questo caso non c'è la necessità di sviluppare i valori, sarà sufficiente inserire al posto della coppia un unovo `-` rappresentante il don't care. 
    $$ \begin{array}{ccc}
        10 & -- & 01 \\ & \downarrow & \\ 2 & - & 1 
    \end{array}$$
- Quando nel gruppo di bit raggruppati il numero di `-` è minore del numero di bit richiesti. In questo caso dobbiamo procedere con l'espansione del dont't care a valori di verità in modo da poter affrontare correttamente la conversione nel nuovo dominio.
        $$ \begin{array}{cccc}
            1- & 11 & 01\\
            & \downarrow &\\
            10 & 11 & 01\\
            11 & 11 & 01\\
            & \downarrow &\\
            2 & 3 & 1\\
            3 & 3 & 1
        \end{array}$$

\newpage

Così facendo è possibile sviluppare tutto il circuito binario e ottenere una conversione esatta. Il circuito convertito
sarà quindi.

```
00 0
02 0
10 0
12 0
01 1
03 -
13 -
23 1
11 2
2- 1
3- 0
```

Con questa struttura è dunque possibile procedere con l'analisi dei circuiti proseguendo con l'attività di sintesi logica.

## Implementazione della conversione

La conversione dei circuiti in analisi viene implementata utilizzando il linguaggio di programmazione Python nella versione 3.8 senza l'ausilio di nessun package esterno, vengono utilizzate solamente librerie comprese nel linguaggio. Questa dinamica fa si che il sistema sia "ready to use" una volta installato il linguaggio di programmazione se non già presente all'interno del SO.

### Analisi del circuito

```python
def read_pla(path_file):
    inp = None
    out = None
    inp_array = []
    out_array = []
    truth_table = []
    with open(path_file, 'r') as input_file:
        for line in input_file.readlines():
            if '.i' in line and line[2] == ' ':
                inp = line.split(' ')[1]
            elif '.o' in line and line[2] == ' ':
                out = line.split(' ')[1]
            elif '.ilb' in line:
                inp_array = line.strip().split(' ')[1:]
            elif '.ob' in line:
                out_array = line.strip().split(' ')[1:]
            elif '.end' in line:
                continue
            else:
                line = {
                    'inp':  line.strip().split(' ')[0],
                    'out':  line.strip().split(' ')[1]
                }
                truth_table.append(line)
    return inp, out, inp_array, out_array, truth_table
```

La funzione prende in input un circuito binario in formato PLA e, riga per riga, analizza le informazioni in base al prefisso all'interno di ogni riga del file che va a differenziare le informazioni del circuito. Scandendo il fil recupera:

- Tabella delle verità
- Numero di input
- Numero di output
- Array contenente il nome delle variabili di input;
- Array contenente il nome delle variabili di output;

Queste informazioni serviranno successivamente per convertire il circuito e calcolare costi.

### Espansione dei don't care

Una volta ottenuto tutte le informazioni disponibili dal circuito dato bisogna andare ad identificare all'interno delle tabelle di verità quali sono i *don't care* a cui bisogna espandere i valori e quelli che si possono ignorare. Questo passaggio è stato la parte più impegnativa riguardante le funzionalità del programma.

```python
n_dont_care = ''
    for i in range(dv):
        n_dont_care += '-'
```

\newpage

Questo semplice ciclo va a replicare il numero di ```-``` consecutivi che rispecchiano i gruppi di don't care da ignorare in base al dominio di conversione dato al circuito.

```python
len_truth_table = len(truth_table)
i = 0
while i < len_truth_table:
    if '-' in truth_table[i]['inp']:
        truth_table[i]['inp'] = ''.join(truth_table[i['inp'])
        truth_table[i]['inp'] = [truth_table[i]['inp'[a:a+dv]
                                 for a in range(0, le(truth_table[i]['inp'], dv)]
        for a in range(len(truth_table[i]['inp'])):
            if truth_table[i]['inp'][a] == n_dont_care:
                truth_table[i]['inp'][a] = 'k'*le(n_dont_care)
        truth_table[i]['inp'] = ''.join(truth_table[i['inp'])
        new_lines = resolve_dont_care(truth_table[i],'inp')
        truth_table = truth_table[:i] + new_lines +truth_table[i+1:]
        len_truth_table = len(truth_table)
    i += 1
```

Per andare a differenziare quali siano i *don't care* da espandere e quali no a quest ultimi viene sostituito il simbolo *-* con un valore *k* in modo da poterli gestire meglio nelle funzioni successive. Alla fine delle operazioni verranno ripristinati con il simbolo corretto.

\newpage

#### Resolve don't care

```python
def resolve_dont_care(line, in_out):
    # Conto qunati - e creo 2^n nuove linee
    n_dc = pow(2, line[in_out].count('-'))

    input_entry = line[in_out]
    new_array = []

    for h in range(line[in_out].count('-')):
        val_array = create_0_1_array(n_dc, pow(2, h))
        if h == 0:
            for i in range(n_dc):
                it = 0
                new_line = []
                for j in range(len(input_entry)-1, -1, -1):
                    if input_entry[j] == '-' and it == 0:
                        new_line.append(val_array[(len(val_array)-1) - i])
                        it += 1
                    else:
                        new_line.append(line[in_out][j])
                new_array.append(new_line[::-1])
        else:
            it = 0
            for c, l in enumerate(new_array):
                for j in range(len(l)-1, -1, -1):
                    if l[j] == '-' and it == 0:
                        l[j] = val_array[(len(val_array)-1) - c]
                        it += 1
                it = 0

    if in_out == 'inp':
        return [{'inp':  l, 'out':  line['out']} for l in new_array]
    else:
        return [{'inp':  line['inp'], 'out':  l} for l in new_array]
```

Questa funzione prende in ingresso la linea da espandere e per ogni sua iterazione *(it)* va a sostituire ogni simbolo ```-``` con un valore di verità. La funzione restituirà la l'espansione della linea.

\newpage

Come possiamo notare dal ```return``` della funzione questa operazione di espansione è possibile sia sugli input che su gli output.

#### create_0_1_array

```python
def create_0_1_array(le, pad):
    count_1 = pad
    count_0 = pad
    return [str(1) if i % (count_1 + count_0) < count_1 
        else str(0) for i in range(le)]
```

Questa funzione restituisce una tabella di verità data una line con all'interno un numero di *don't care* che necessitano di espansione.

Questo tabella creata verrà inserita al posto della linea con i *don't care* del circuito in così da avere la tabella corretta per la conversione.

\newpage

## La conversione in multi valore

Le funzioni viste nelle sezioni precedenti restituiscono come valore di output una matrice corrispondente alla tabella della verità sviluppata. Questa tabella verrà utilizzata dalla funzione di conversione seguendo lo schema spiegato all'inizio del capitolo.

```python
def create_mv_truth_table(truth_array, dv):
    conv_truth = []
    for line in truth_array:
        line['inp'] = ''.join(line['inp'])
        line['inp'] = [line['inp'][i * dv:(i + 1) * dv]
            for i in range((len(line['inp']) + dv - 1) // dv)]
        if '-' not in line['out']:
            line['out'] = ''.join(line['out'])
            line['out'] = [line['out'][i * dv:(i + 1) * dv]
                for i in range((len(line['out']) + dv - 1) // dv)]
            l_supp_inp = []
            l_supp_out = []
            for val in line['inp']:
                if '-' not in val:
                    l_supp_inp.append(int(val, 2))
                else:
                    l_supp_inp.append('-')
            for val in line['out']:
                l_supp_out.append(int(val, 2))
            conv_truth.append({
                'inp':  l_supp_inp,
                'out':  l_supp_out
            })
    return conv_truth
```

La funzione prende in ingresso la matrice espansa creata precedentemente e il numero di bit da utilizzare per rappresentare il massimo numero del nuovo dominio multivalore.

Inizialmente la funzione 'spezza' la stringa dei valori di input in gruppi di tanti elementi quanti sono i bit per rappresentare il massimo numero, successivamente viene controllato se il gruppo è composto da:

- **dont't care**: si procede sostituendo con un singolo simbolo '-'
- **numeri binari**: si procede con la conversione tramite il metodo int(), ad esso servono 2 parametri:
    - un numero o una stringa di numeri da convertire
    - la base a cui si vuole fare la conversione

Una volta scandita tutta la tabella di verità siamo giunti al circuito convertito, l'utlimo passo ora consiste nell'andare a creare un file compatibile per la sintesi dei circuiti.

## La creazione del file blfmv

Per i circuiti multi valore non viene adottato il formato PLA in quanto viene utilizzato solamente per i circuiti binari. Facciamo uso di un altro formato standard appositamente creato per la logica multi valore, il formato *blfmv*.

Questo formato deriva dal formato *blif* utilizzato per la logica binaria.

```python
import string
mv_input = [i for i in list(string.ascii_lowercase)[
    :len(mv_table[0]['inp'])]]
mv_output = ['o{}'.format(i) for i in range(len(mv_table[0]['out']))]
with open('{}/blfmv/{}.mv'.format(working_dir, nomefile), 'w') as blif:
    blif.write('.model {}\n'.format(working_dir, nomefile))
    blif.write('.inputs {}\n'.format(
        ' '.join(map(str, mv_input))))
    blif.write('.outputs {}\n'.format(
        ' '.join(map(str, mv_output))))
    blif.write('.mv {} {}\n'.format(
        ', '.join(map(str, mv_input)), mv))
    blif.write('.mv {} {}\n'.format(
        ', '.join(map(str, mv_output)), mv))
    for count, out in enumerate(mv_output):
        blif.write('.table {} {}\n'.format(' '.join(map(str,mv_input)), out))
        for line in mv_table:
            blif.write('{} {}\n'.format(
                ' '.join(map(str, line['inp'])), line['out'][count]))
    blif.write('.end\n')
```

Questa funzione crea un file *.mv* relativo al circuito creato. Scegliamo questa tipo di file e sintassi poiché nelle fasi successive utilizzeremo dei software che accettano questa sintassi per valutare e sintetizzare i circuiti.

\newpage

## La sintesi

Una volta ottenuto sia il circuito booleano che quello multivalore procediamo con la sintesi dei circuiti. Quest'ultima si pone l'obiettivo di ridurre e ottimizzare la struttura dei circuiti stessi andando a diminuire il numero di ingressi e di tabelle della verità in modo da avere dei costi totali minori.

I programmi utilizzati per la sintesi logica sono entrambi sviluppati dall'università di Berkley e sono disponibili con licenza open source.

Per la sintesi durante l'analisi sperimentale sono state utilizzate 2 alternative:

- MVSIS
- ABC

### MVSIS

E' il primo programma utilizzato, al suo interno troviamo diversi metodi di sintesi da poter applicare che sfruttano tecniche differenti. La particolarità di questo tool consiste nel fatto che il programma accetti come input sia circuiti binari che multivalore. Il lato negativo dell'utilizzo di questo porgramma è che l'ultima versione di questo software risale al 2005 e quindi non è più mantenuto.

### ABC

ABC, come la sua alternativa descritta sopra, mette a disposizione delle tecniche di sintesi con il vantaggio di avere degli script pronti che uniscono più metodi in modo da avere la certezza di non commettere errori o di utilizzare una concatenazione di metodi inefficace.

ABC è un'evoluzione di MVSIS e del più vecchio SIS. Viene tuttora mantenuto ma, a differenza di MVSIS, se gli viene dato in ingresso un valore di input esso viene successivamente convertito in binario e solo in seguito è possibile utilizzare i metodi di sintesi.

Una caratteristica molto utile di questi programmi sta nel fatto che essi accettano come parametri di ingresso degli script contenenti tutte le istruzioni da eseguire.Successivamente mostrerò come tutto il processo di analisi viene automatizzato sfruttando questa caratteristica.

\newpage

### La sintesi tramite i software

La letteratura mette già a disposizione delle sequenze di metodi di sintesi e pulizia dei circuiti efficace ed efficiente, questi comandi si possono chiamare semplicemente dando in input ai due programmi un file contenente un alias per questa sequenza di istruzioni.

```
source abc_alias.abc
read_blif_mv ./prova/blfmv/amd.mv
strash
compress2
cl
resyn2
cl
write_blif_mv ./prova/blfmv/synth/amd.mv
```

Il programma, in questo caso *abc*, non fa altro che prendere come input uno dei circuiti creati precedentemente e,  applicando i metodi di sintesi crea un altro file contenente il circuito sintetizzato. In questo modo è successivamente possibile fare dei successivi confronti una volta sintetizzati tutti i circuiti.

## Il calcolo dei costi del circuito

Il costo del circuito viene calcolato sulla base 2 fattori fondamentali:

- Quanti input devono inviare entrambe le parti
- Quanti valori devono inviare per ciascun valore di input in base al dominio

Per calcolare questo tipo di informazioni si devono effettuare delle operazioni di lettura sui file precedentemente creati analizzando 2 fattori:

- Gli ingressi di ogni tabella di verità del circuito (andando a controllare quali dei valori di input devono essere inseriti da una delle parti e quali sono ingressi di valori di output delle altre tabelle.)
- Il dominio dei valori di input che devono inserire le parti.

\newpage

### blfmv vs pla

Per fare il confronto sopra citato si è preferito utilizzare file che avessero la stessa sintassi di rappresentazione del circuito, sia nel caso multi valore che in quello booleano.

Il formato *pla* non dispone di un'alternativa per i file multivalore ma non è ancora supportata dai tool che abbiamo in utilizzo. Per questo motivo si è deciso di utilizzare il formato *blif* per rappresentare i circuiti binari. *Blif* è l'alternativa binaria a *blfmv*, la sintassi è la stessa con la differenza che non viene specificato il dominio dei valori di input in quanto sempre booleano.

La differenza con *pla* invece sta nel fatto che gli output non possono essere più di 1 per tabella: nella rappresentazione avrò quindi, per ogni nodo del circuito, tante tabelle quanti gli output di quel nodo. Questa tipologia di rappresentazione è utilizzata anche nei file *blfmv* quindi sarà possibile una comparazione 1:1 tra binario e multivalore.

Per effettuare questa conversione vengono in aiuto i tool *ABC* e *MVSIS* poiché entrambi contengono metodi di conversione automatica da *pla* a *blif*. Questa operazione viene effettuata tramite uno script contenente le istruzioni da eseguire e dato come parametro di ingresso al programma.

```
read_pla ./prova/pla/alu2.pla
write_blif ./prova/blif/alu2.blif
```

Ora abbiamo a disposizione tutti i file per poter fare il confronto dei costi

### Implementazione

```python
with open('{}/{}'.format(working_dir, circuito)) as circ:
    input = None
    output = None
    mv = int(0)
    table_array = []
    for line in circ.readlines():
        if '.inputs' in line.strip():
            input = line.strip().split(' ')[1:]
        if '.outputs' in line.strip():
            output = line.strip().split(' ')[1:]
        if '.mv' in line.strip():
            if mv < int(line.strip().split(' ')[-1]):
                mv = int(line.strip().split(' ')[-1])
        if '.table' in line.strip():
            l = line.strip().split(' ')
            table_array.append(
                {
                    'input':    l[1:len(l)-1],
                    'output':   l[-1]
                }
            )
        if '.names' in line.strip():
            l = line.strip().split(' ')
            table_array.append(
                {
                    'input':    l[1:len(l)-1],
                    'output':   l[-1]
                }
            )
    # i blif non hanno .mv, quindi gli do il valore di dominio
    if mv == 0:
        mv = 2
    return {
        'dominio':   mv,
        'input':    input,
        'output':   output,
        'tabelle':  table_array
    }
```

In questa funzione, dato un circuito sia binario che mutli-valore, esso prende tutte le informazioni utili per poter effettuare il calcolo

```python
costo = 0
for t in circuito['tabelle']:
    intersection = len(set(circuito['input']).intersection(t['input']))
    costo = costo + pow(circuito['dominio'], intersection)
return costo
```

Fatto questo ho ottenuto tutti i valori di costo sia dei circuiti booleani che binari.

```python
with open('calcolo_costi.csv', 'a') as file:
    file.write(
        'NOME CIRC;COSTO BOOLEANO;INPUT ALICE;INPUT BOB;DOMINIO MULTIVALORE;COSTO MULTIVALORE;INPUT ALICEINPUT BOB\n')
    for blfmv in listdir('{}/blfmv'.format(working_dir)):
        if blfmv.endswith('.mv'):
            print(blfmv)
            circ_mv = info_circuito(
                '{}/blfmv/synth'.format(working_dir),blfmv)
            costo_mv = calcolo_costo_circuito(circ_mv)
            if len(circ_mv['input']) % 2 != 0:
                alice_var_mv = int(len(circ_mv['input'])/ 2)
                bob_var_mv = int(len(circ_mv['input']) /2) + 1
            else:
                alice_var_mv = int(len(circ_mv['input'])/ 2)
                bob_var_mv = int(len(circ_mv['input']) /2)
            circ_bool = info_circuito(
                '{}/blif/synth'.format(working_dir), '{}blif'.format(blfmv.split('.')[0]))
            costo_bool = calcolo_costo_circuito(circ_bool)
            if len(circ_bool['input']) % 2 != 0:
                alice_var_bool = int(len(circ_boo['input']) / 2)
                bob_var_bool = int(len(circ_bool['input') / 2) + 1
            else:
                alice_var_bool = int(len(circ_boo['input']) / 2)
                bob_var_bool = int(len(circ_bool['input') / 2)
            file.write('{};{};{};{};{};{};{};{}\n'.forma(blfmv.split('.')[
                0], costo_bool, alice_var_bool,bob_var_bool, circ_mv['dominio'],costo_mv, alice_var_mv, bob_var_mv))
```

Una volta ottenute tutte le informazioni, per avere una migliore visione per l'analisi, esse vengono salvate all'interno di una file *CVS* con la funzione sopra mostrata.

\newpage

## Automatizzazione dei processi

Tutte le fasi mostrate sopra, più altre secondarie, sono state automatizzate in modo che non si debbano effettuare operazioni ridondati per ogni circuito e generare perdite di dati causate da errori umani.

### Struttura

```
.
├── abc_alias.abc           #alias con metodi sintesi ABC
├── automate.py             #automatizzatore dei processi
├── calcolo_costi.csv
├── calcolo_costi_no_synth.csv
├── facili  #directory contenente i file d'analisi
│   ├── blfmv
│   │   └── synth # circuiti sintetizzati
│   ├── blif
│   │   └── synth
│   └── pla_extended #pla espansi per debugging
├── lib_mv  # libreria con tutti le funzioni create
│   ├── automate_mvsis.py
│   ├── bin_to_mv.py
│   └── caloclo_costo.py
├── pla_to_blif.mvsis   #file con sintesi per MVSIS
├── synth_bool.abc      #file di sintesi  binaria per ABC
└── synth_mv.abc        #file di sintesi multivalore per ABC
```


```python
working_dir = './prova'
if path.exists('{}/blif'.format(working_dir)) and pathexists('{}/blfmv'.format(working_dir)):
    rmtree('{}/blif'.format(working_dir))
    rmtree('{}/blfmv'.format(working_dir))
  
makedirs('{}/blif/synth'.format(working_dir))
makedirs('{}/blfmv/synth'.format(working_dir))
if path.exists('{}/synth_out.mvsis'.format(working_dir)):
    remove('{}/synth_out.mvsis'.format(working_dir))

if not path.exists('{}/pla'.format(working_dir)):
    print('CARTELLA PLA NON PRESENTE')
    exit
```

\newpage 

In questa fase viene creata la struttura delle directory che conterranno i file con i circuiti sintetizzati, se questa struttura è già presente vengono cancellate tutte le cartelle e i file all'interno e successivamente ricreate le cartelle vuote. 

```python
bin_to_mv_mcd(working_dir)
if exists('./pla_to_blif.mvsis'):
    remove('./pla_to_blif.mvsis')
pla_to_blif(working_dir)
```

in questa sezione vengono chiamate 2 utility create con lo scopo di generare dei file utilizzabili da *ABC* e *MVSIS*.

- **bin_to_mv_mcd**: ha lo scopo di creare i file *blfmv* di ogni circuito all'interno della directory di lavoro
**pla_to_blif**: prende dalla directory di lavoro i file *pla* contenenti i circuiti e li converte in *blif*, come visto nei paragrafi precedenti.


```python
call(['abc', '-F', './pla_to_blif.mvsis'])
synth(working_dir)
call(['abc', '-F', './synth_bool.abc'])
call(['abc', '-F', './synth_mv.abc'])
```

Una volta creati questi file compatibili con i nostri tool di sintesi essi vengono passati come parametro ad *ABC* o *MVSIS* s seconda delle esigenze di analisi.

```python
if exists('./calcolo_costi.csv'):
    remove('./calcolo_costi.csv')
if exists('./calcolo_costi_no_synth.csv'):
    remove('./calcolo_costi_no_synth.csv')
```

Viene poi controllato se è presente già un file contenente dei costi e, se c'è, lo elimina

```python
calcolo_costi_synth(working_dir)
calcolo_costi_no_synth(working_dir)
```

Le operazioni di calcolo dei costo vengono effettuate e infine viene generato il file *CSV* contenente i risultati.